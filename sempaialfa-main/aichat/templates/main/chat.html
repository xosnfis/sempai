{% load static %}
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Чат - Альфа-Ассистент</title>
    <link rel="stylesheet" href="{% static 'css/style.css' %}?v={{ cache_version }}">
    <link rel="stylesheet" href="{% static 'css/charts.css' %}?v={{ cache_version }}">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&family=Manrope:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <!-- Библиотека для экспорта в PNG -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <!-- Система индикаторов загрузки -->
    <script src="{% static 'js/loading-indicators.js' %}?v={{ cache_version }}"></script>
    <!-- Lazy Loading для изображений -->
    <script src="{% static 'js/lazy-loading.js' %}?v={{ cache_version }}"></script>
    <!-- Система обработки ошибок -->
    <script src="{% static 'js/error-handler.js' %}?v={{ cache_version }}"></script>
    <!-- Система модальных окон -->
    <script src="{% static 'js/modal.js' %}?v={{ cache_version }}"></script>
    <!-- Система визуализации данных (графики) -->
    <script src="{% static 'js/charts.js' %}?v={{ cache_version }}"></script>
    <!-- Мобильное меню -->
    <script src="{% static 'js/mobile-menu.js' %}?v={{ cache_version }}"></script>
</head>
<body class="chat-page">
    <div class="chat-container">
        <!-- Sidebar Overlay (Mobile) -->
        <div class="chat-sidebar-overlay" id="chatSidebarOverlay" onclick="toggleChatSidebar()"></div>
        
        <!-- Left Sidebar -->
        <aside class="chat-sidebar" id="chatSidebar">
            <div class="chat-sidebar-header">
                <div class="chat-logo-header-wrapper">
                <div class="chat-logo">
                        <a href="{% url 'cabinet' %}" class="chat-logo-link" onclick="if (window.innerWidth > 768 && document.getElementById('chatSidebar')?.classList.contains('chat-sidebar-collapsed')) { event.preventDefault(); toggleSidebarCollapse(); }">
                            <div class="chat-logo-box">
                                <span class="chat-logo-text">Alfa-AI</span>
                            </div>
                    </a>
                    </div>
                    <!-- Кнопка сворачивания/разворачивания -->
                    <button class="chat-sidebar-toggle-btn" id="chatSidebarToggleBtn" onclick="toggleSidebarCollapse();" title="Свернуть/развернуть панель">
                        <svg class="chat-sidebar-toggle-icon" width="18" height="18" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <path d="M15 18L9 12L15 6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                        </svg>
                    </button>
                </div>
            </div>
            
            <div class="chat-sidebar-content">
                <button class="chat-new-chat-btn" data-i18n="new-chat">Новый чат</button>
                <button class="chat-favorites-btn" id="favoritesBtn" data-i18n="favorites">Избранное</button>
                <input type="text" class="chat-search-input" id="chatSearchInput" data-i18n-placeholder="search-chats" placeholder="Поиск по чатам">
                
                <div id="chatHistorySection"></div>
            </div>
            
            <div class="chat-sidebar-footer">
                <button class="chat-profile-btn" id="chatThemeBtn" onclick="toggleChatTheme()">
                    <span class="chat-profile-text" id="chatThemeBtnText">Тема</span>
                </button>
            </div>
        </aside>

        <!-- Main Chat Area -->
        <main class="chat-main">
            <div class="chat-main-header">
                <button class="chat-burger-btn" id="chatBurgerBtn" onclick="toggleChatSidebar()">
                    <span class="chat-burger-line"></span>
                    <span class="chat-burger-line"></span>
                    <span class="chat-burger-line"></span>
                </button>
                <a href="{% url 'cabinet' %}" class="chat-home-btn">
                    <img src="{% static 'images/na_glavn.png' %}" alt="На главную" class="chat-home-icon" loading="lazy">
                </a>
            </div>
            
            <div class="chat-content">
                <div class="chat-messages-area" id="chatMessages">
                    <div class="chat-ai-widget-main" id="chatWelcome">
                        <div class="chat-ai-icon-main">
                            <span class="chat-ai-icon-text-main">AI</span>
                        </div>
                        <div class="chat-ai-prompt">С чего начнём, Босс?</div>
                    </div>
                    <div class="chat-capability-messages" id="chatCapabilityMessages">
                        <!-- Сообщения с возможностями будут добавлены через JavaScript -->
                    </div>
                </div>
                
                <!-- Кнопка экспорта всего чата -->
                <div class="chat-export-all-button" id="chatExportAllButton" style="display: none;">
                    <button onclick="showExportChatModal()" title="Экспорт всего чата" class="chat-export-all-btn">
                        <img src="{% static 'images/skachat.svg' %}" alt="Экспорт" style="width: 24px; height: 24px;" loading="lazy">
                    </button>
                </div>
                
                <div class="chat-input-wrapper">
                    <div id="attachedFiles" class="attached-files-list" style="display: none;"></div>
                    <div class="chat-input-container">
                        <input type="file" id="fileInput" style="display: none;" multiple>
                        <input type="text" class="chat-input" id="chatInput" data-i18n-placeholder="ask-me-something" placeholder="Спросите у меня что-нибудь..">
                        <div class="chat-input-actions">
                            <button type="button" class="chat-attach-btn" id="attachBtn">
                                <img src="{% static 'images/prikrepit_file_svatl.png' %}" alt="Прикрепить файл" loading="lazy">
                            </button>
                            <button class="chat-send-btn" id="chatSendBtn">
                                <img src="{% static 'images/otpravit.png' %}" alt="Отправить" loading="lazy">
                            </button>
                            <button type="button" class="chat-suggestions-btn" id="chatSuggestionsBtn" onclick="toggleSuggestionsModal()" title="Примеры вопросов">
                                <img src="{% static 'images/light.png' %}" alt="Примеры вопросов" style="width: 20px; height: 20px;" loading="lazy">
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <!-- Suggestions Modal -->
    <div class="suggestions-modal" id="suggestionsModal" style="display: none;">
        <div class="suggestions-modal-content">
            <div class="suggestions-modal-header">
                <h3 class="suggestions-modal-title">Примеры вопросов</h3>
                <button class="suggestions-modal-close" onclick="toggleSuggestionsModal()">×</button>
            </div>
            <div class="suggestions-modal-body" id="suggestionsModalBody">
                <!-- Примеры вопросов будут добавлены через JavaScript -->
            </div>
        </div>
    </div>

    <!-- Confirmation Modal -->
    <div class="confirm-modal" id="confirmModal" style="display: none;">
        <div class="confirm-modal-content">
            <div class="confirm-modal-header">
                <h3 class="confirm-modal-title">Подтверждение</h3>
            </div>
            <div class="confirm-modal-body">
                <p class="confirm-message" id="confirmMessage"></p>
            </div>
            <div class="confirm-modal-actions">
                <button class="confirm-btn confirm-btn-cancel" onclick="closeConfirmModal()">Отмена</button>
                <button class="confirm-btn confirm-btn-confirm" id="confirmBtn">Подтвердить</button>
            </div>
        </div>
    </div>

    <!-- Edit Chat Title Modal -->
    <div class="confirm-modal" id="editChatModal" style="display: none;">
        <div class="confirm-modal-content">
            <div class="confirm-modal-header">
                <h3 class="confirm-modal-title">Редактировать название чата</h3>
            </div>
            <div class="confirm-modal-body">
                <input type="text" id="editChatTitleInput" class="chat-edit-title-input" placeholder="Введите новое название">
            </div>
            <div class="confirm-modal-actions">
                <button class="confirm-btn confirm-btn-cancel" onclick="closeEditChatModal()">Отмена</button>
                <button class="confirm-btn confirm-btn-confirm" id="saveEditChatBtn">Сохранить</button>
            </div>
        </div>
    </div>

    <!-- Export Chat Modal -->
    <div class="confirm-modal" id="exportChatModal" style="display: none;">
        <div class="confirm-modal-content">
            <div class="confirm-modal-header">
                <h3 class="confirm-modal-title">Экспорт чата</h3>
            </div>
            <div class="confirm-modal-body">
                <p style="margin-bottom: 20px; color: #666;">Выберите формат для экспорта всего чата:</p>
                <div class="export-options-grid">
                    <button class="export-option-btn" onclick="exportChatDOCX(); closeExportChatModal();" title="Экспорт в Word документ">
                        <span class="export-option-icon"><img src="{% static 'images/txt.png' %}" alt="DOCX" loading="lazy"></span>
                        <span class="export-option-text">DOCX</span>
                        <span class="export-option-desc">Word документ</span>
                    </button>
                    <button class="export-option-btn" onclick="exportChatCSV(); closeExportChatModal();" title="Экспорт в CSV">
                        <span class="export-option-icon"><img src="{% static 'images/csv.png' %}" alt="CSV"></span>
                        <span class="export-option-text">CSV</span>
                        <span class="export-option-desc">Таблица Excel</span>
                    </button>
                    <button class="export-option-btn" onclick="exportChatPNG(); closeExportChatModal();" title="Экспорт в PNG">
                        <span class="export-option-icon"><img src="{% static 'images/png.png' %}" alt="PNG"></span>
                        <span class="export-option-text">PNG</span>
                        <span class="export-option-desc">Изображение</span>
                    </button>
                </div>
            </div>
            <div class="confirm-modal-actions">
                <button class="confirm-btn confirm-btn-cancel" onclick="closeExportChatModal()">Отмена</button>
            </div>
        </div>
    </div>

    <script>
        // Пути к изображениям
        const IMAGE_PATHS = {
            tem_tema: "{% static 'images/tem_tema.svg' %}",
            sv_tema: "{% static 'images/sv_tema.svg' %}",
            zakrep2: "{% static 'images/zakrep2.svg' %}",
            red: "{% static 'images/red.svg' %}",
            udalit: "{% static 'images/udalit.png' %}",
            csv: "{% static 'images/csv.png' %}",
            txt: "{% static 'images/txt.png' %}",
            png: "{% static 'images/png.png' %}"
        };
        
        // Получить чаты текущего пользователя
        function getUserChats() {
            const currentUser = JSON.parse(localStorage.getItem('currentUser') || '{}');
            const email = currentUser.email || '';
            if (!email) return [];
            const key = `chats_${email}`;
            return JSON.parse(localStorage.getItem(key) || '[]');
        }
        
        // Сохранить чаты текущего пользователя
        function saveUserChats(chatsArray) {
            const currentUser = JSON.parse(localStorage.getItem('currentUser') || '{}');
            const email = currentUser.email || '';
            if (!email) return;
            const key = `chats_${email}`;
            localStorage.setItem(key, JSON.stringify(chatsArray));
        }
        
        // Получить избранные чаты текущего пользователя
        function getUserFavorites() {
            const currentUser = JSON.parse(localStorage.getItem('currentUser') || '{}');
            const email = currentUser.email || '';
            if (!email) return [];
            const key = `favorites_${email}`;
            return JSON.parse(localStorage.getItem(key) || '[]');
        }
        
        // Сохранить избранные чаты текущего пользователя
        function saveUserFavorites(favoritesArray) {
            const currentUser = JSON.parse(localStorage.getItem('currentUser') || '{}');
            const email = currentUser.email || '';
            if (!email) return;
            const key = `favorites_${email}`;
            localStorage.setItem(key, JSON.stringify(favoritesArray));
        }
        
        // Получить закрепленные чаты текущего пользователя
        function getUserPinnedChats() {
            const currentUser = JSON.parse(localStorage.getItem('currentUser') || '{}');
            const email = currentUser.email || '';
            if (!email) return [];
            const key = `pinnedChats_${email}`;
            return JSON.parse(localStorage.getItem(key) || '[]');
        }
        
        // Сохранить закрепленные чаты текущего пользователя
        function saveUserPinnedChats(pinnedChatsArray) {
            const currentUser = JSON.parse(localStorage.getItem('currentUser') || '{}');
            const email = currentUser.email || '';
            if (!email) return;
            const key = `pinnedChats_${email}`;
            localStorage.setItem(key, JSON.stringify(pinnedChatsArray));
        }
        
        // Управление чатами
        let currentChatId = null;
        let chats = getUserChats();
        let favorites = getUserFavorites();
        let pinnedChats = getUserPinnedChats();
        let showFavoritesOnly = false;
        let searchQuery = '';
        
        // Управление прикрепленными файлами
        let attachedFiles = [];

        // Восстановление активных запросов при загрузке страницы
        function restoreActiveRequests() {
            chats.forEach(chat => {
                chat.messages.forEach(msg => {
                    if (!msg.isUser && msg.requestId && msg.text === 'Думаю...') {
                        // Восстанавливаем проверку статуса для незавершенных запросов
                        activeRequests.set(msg.requestId, { chatId: chat.id, startTime: Date.now() });
                        checkRequestStatus(msg.requestId, chat.id);
                    }
                });
            });
        }
        
        // Простые функции для экспорта и редактирования (только localStorage)
        let editingMessageIndex = -1;
        
        function downloadFile(content, filename, mimeType) {
            try {
                const blob = new Blob([content], { type: `${mimeType};charset=utf-8` });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = filename;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
            } catch (error) {
                console.error('Ошибка при скачивании файла:', error);
                showError('Ошибка при экспорте. Проверьте консоль браузера.');
            }
        }
        
        function exportChatJSON() {
            if (!currentChatId) {
                showWarning('Нет активного чата');
                return;
            }
            const chat = chats.find(c => c.id === currentChatId);
            if (!chat) {
                showError('Чат не найден');
                return;
            }
            
            const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
            const filename = `chat_${chat.title.replace(/[^a-z0-9]/gi, '_')}_${timestamp}.json`;
            
            const data = {
                title: chat.title,
                chat_id: chat.id,
                created_at: chat.createdAt,
                updated_at: new Date().toISOString(),
                total_messages: chat.messages.length,
                messages: chat.messages.map(msg => ({
                    text: msg.text,
                    isUser: msg.isUser,
                    timestamp: msg.timestamp,
                    files: msg.files || [],
                    edited: msg.edited || false,
                    edited_at: msg.edited_at || null
                }))
            };
            
            const dataStr = JSON.stringify(data, null, 2);
            downloadFile(dataStr, filename, 'application/json');
        }
        
        async function exportChatDOCX() {
            if (!currentChatId) {
                showWarning('Нет активного чата');
                return;
            }
            const chat = chats.find(c => c.id === currentChatId);
            if (!chat) {
                showError('Чат не найден');
                return;
            }
            
            try {
                // Отправляем данные чата напрямую на сервер для генерации DOCX
                const response = await fetch('/api/export-chat-docx/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        title: chat.title,
                        chat_id: chat.id,
                        messages: chat.messages
                    })
                });
                
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error || 'Ошибка сервера');
                }
                
                // Получаем файл как blob
                const blob = await response.blob();
                const url = window.URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `chat_${chat.title.replace(/[^a-z0-9]/gi, '_')}_${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.docx`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                window.URL.revokeObjectURL(url);
            } catch (error) {
                console.error('Ошибка при экспорте в DOCX:', error);
                showError(`Ошибка при экспорте документа: ${error.message}`);
            }
        }
        
        // Вспомогательные функции для улучшенного CSV экспорта
        
        // Форматирование денежных сумм (для CSV - без пробелов, чтобы Excel правильно распознавал)
        function formatCurrency(value, currency = '₽') {
            if (typeof value !== 'number' || isNaN(value)) return '';
            
            // Для CSV используем точку как десятичный разделитель (Excel сам преобразует)
            // И добавляем символ валюты в конец
            return value.toFixed(2) + ' ' + currency;
        }
        
        // Форматирование денежных сумм с разделителями (для отображения)
        function formatCurrencyDisplay(value, currency = '₽') {
            if (typeof value !== 'number' || isNaN(value)) return '';
            
            // Форматируем с разделителями тысяч и запятой для копеек
            const formatted = value.toFixed(2).replace(/\B(?=(\d{3})+(?!\d))/g, ' ');
            // Заменяем точку на запятую для российского формата
            return formatted.replace('.', ',') + ' ' + currency;
        }
        
        // Форматирование чисел (для CSV - без пробелов, чтобы Excel правильно распознавал)
        function formatNumber(value) {
            if (typeof value !== 'number' || isNaN(value)) return '';
            
            // Для целых чисел - без форматирования для Excel
            if (Number.isInteger(value)) {
                return value.toString();
            }
            
            // Для десятичных - используем точку для Excel (Excel сам преобразует)
            return value.toFixed(2);
        }
        
        // Форматирование чисел с разделителями (для отображения)
        function formatNumberDisplay(value) {
            if (typeof value !== 'number' || isNaN(value)) return '';
            
            // Для целых чисел
            if (Number.isInteger(value)) {
                return value.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ' ');
            }
            
            // Для десятичных
            return value.toFixed(2).replace(/\B(?=(\d{3})+(?!\d))/g, ' ').replace('.', ',');
        }
        
        // Форматирование дат
        function formatDate(dateString, format = 'ru-RU') {
            if (!dateString) return '';
            
            try {
                const date = new Date(dateString);
                if (isNaN(date.getTime())) {
                    return dateString;
                }
                return date.toLocaleString(format, {
                    year: 'numeric',
                    month: '2-digit',
                    day: '2-digit',
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit'
                });
            } catch {
                return dateString;
            }
        }
        
        // Определение типа колонки
        function detectColumnType(header, sampleValue) {
            const headerLower = header.toLowerCase();
            
            // Денежные суммы
            if (headerLower.includes('стоимость') || headerLower.includes('сумма') || headerLower.includes('цена')) {
                return 'currency';
            }
            
            // Количества
            if (headerLower.includes('количество') || headerLower.includes('кол-во')) {
                return 'quantity';
            }
            
            // Даты
            if (headerLower.includes('дата') || headerLower.includes('время')) {
                return 'date';
            }
            
            // Числа
            if (!isNaN(sampleValue) && sampleValue !== '') {
                return 'number';
            }
            
            return 'text';
        }
        
        // Очистка Markdown форматирования
        function cleanMarkdownFormatting(text) {
            if (!text) return '';
            return text
                .replace(/\*\*/g, '')      // Убираем жирный текст **
                .replace(/\*/g, '')        // Убираем курсив *
                .replace(/`/g, '')         // Убираем код `
                .replace(/\[([^\]]+)\]\([^\)]+\)/g, '$1')  // Убираем ссылки [текст](url) -> текст
                .replace(/^#+\s+/gm, '')   // Убираем заголовки # ## ###
                .replace(/^!!\s*/g, '')    // Убираем специальные маркеры !!
                .trim();
                }
                
        // Улучшенное экранирование CSV значений (для точки с запятой как разделителя)
        function escapeCSV(value) {
            if (value === null || value === undefined) {
                return '';
            }
            
            const str = String(value).trim();
            
            // Убираем Markdown форматирование
            let cleaned = cleanMarkdownFormatting(str);
            
            // Убираем лишние пробелы
            cleaned = cleaned.replace(/\s+/g, ' ');
            
            // Если значение пустое или только пробелы
            if (!cleaned || cleaned.trim() === '') {
                return '';
                }
                
            // Экранируем кавычки (удваиваем их)
            const escaped = cleaned.replace(/"/g, '""');
            
            // Если значение содержит точку с запятой, запятую, перенос строки, кавычку или пробелы в начале/конце - оборачиваем в кавычки
            if (escaped.includes(';') || 
                escaped.includes(',') || 
                escaped.includes('\n') || 
                escaped.includes('\r') || 
                escaped.includes('"') ||
                escaped.trim() !== escaped) {
                return `"${escaped}"`;
            }
            
            return escaped;
        }
        
        function exportChatCSV() {
            if (!currentChatId) {
                showWarning('Нет активного чата');
                return;
            }
            const chat = chats.find(c => c.id === currentChatId);
            if (!chat) {
                showError('Чат не найден');
                return;
            }
            
            const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
            const filename = `chat_${chat.title.replace(/[^a-z0-9]/gi, '_')}_${timestamp}.csv`;
            
            let csv = 'Время;Роль;Сообщение;Файлы;Отредактировано\n';
            
            chat.messages.forEach(msg => {
                const msgTimestamp = msg.timestamp ? new Date(msg.timestamp).toLocaleString('ru-RU') : 'Неизвестно';
                const role = msg.isUser ? "Пользователь" : "AI";
                const text = (msg.text || '').replace(/\n/g, ' ').replace(/\r/g, '');
                const files = (msg.files || []).map(f => typeof f === 'string' ? f : (f.name || f)).join('; ');
                const edited = msg.edited ? 'Да' : 'Нет';
                
                csv += `${escapeCSV(msgTimestamp)};${escapeCSV(role)};${escapeCSV(text)};${escapeCSV(files)};${escapeCSV(edited)}\n`;
            });
            
            // Создаем CSV с UTF-8 BOM для правильного отображения в Excel
            const BOM = '\uFEFF';
            const csvWithBOM = BOM + csv;
            
            // Создаем Blob с правильной кодировкой
            const blob = new Blob([csvWithBOM], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        }
        
        // Вспомогательная функция для определения правильного фона при экспорте
        function getBackgroundColorForExport() {
            const isDarkTheme = document.body.classList.contains('dark-theme');
            
            // Определяем фон области сообщений
            const messagesArea = document.getElementById('chatMessages');
            if (messagesArea) {
                const bgColor = window.getComputedStyle(messagesArea).backgroundColor;
                if (bgColor && bgColor !== 'rgba(0, 0, 0, 0)' && bgColor !== 'transparent') {
                    return bgColor;
                }
            }
            
            // Фон по умолчанию в зависимости от темы
            return isDarkTheme ? '#1a1a1a' : '#ffffff';
        }
        
        // Агрессивная функция для удаления всех эффектов затемнения/осветления
        function removeAllVisualEffects(element) {
            const allElements = element.querySelectorAll('*');
            const elementsToClean = [element, ...Array.from(allElements)];
            
            elementsToClean.forEach(el => {
                const computedStyle = window.getComputedStyle(el);
                const elStyle = el.style;
                
                // АГРЕССИВНО удаляем все тени через inline стили
                elStyle.setProperty('box-shadow', 'none', 'important');
                elStyle.setProperty('-webkit-box-shadow', 'none', 'important');
                elStyle.setProperty('-moz-box-shadow', 'none', 'important');
                elStyle.setProperty('text-shadow', 'none', 'important');
                
                // Удаляем все фильтры
                elStyle.setProperty('filter', 'none', 'important');
                elStyle.setProperty('-webkit-filter', 'none', 'important');
                elStyle.setProperty('-moz-filter', 'none', 'important');
                elStyle.setProperty('backdrop-filter', 'none', 'important');
                elStyle.setProperty('-webkit-backdrop-filter', 'none', 'important');
                
                // Убираем прозрачность
                elStyle.setProperty('opacity', '1', 'important');
                
                // Убираем blur из transform, но сохраняем другие трансформации
                if (computedStyle.transform && computedStyle.transform.includes('blur')) {
                    const newTransform = computedStyle.transform.replace(/blur\([^)]+\)/g, '').trim();
                    if (newTransform) {
                        elStyle.setProperty('transform', newTransform, 'important');
                    } else {
                        elStyle.removeProperty('transform');
                    }
                }
            });
            
            // Скрываем все overlay элементы
            const overlayElements = element.querySelectorAll('.chat-sidebar-overlay, [class*="overlay"], [class*="Overlay"]');
            overlayElements.forEach(overlay => {
                overlay.style.display = 'none';
                overlay.style.opacity = '0';
                overlay.style.visibility = 'hidden';
            });
        }
        
        // Функция для очистки клонированного DOM от всех эффектов
        function cleanClonedDOM(clonedDoc) {
            const clonedBody = clonedDoc.body || clonedDoc.documentElement;
            if (!clonedBody) return;
            
            // Удаляем все overlay элементы
            const overlays = clonedBody.querySelectorAll('.chat-sidebar-overlay, [class*="overlay"], [class*="Overlay"]');
            overlays.forEach(overlay => overlay.remove());
            
            // Очищаем все элементы от эффектов
            const allElements = clonedBody.querySelectorAll('*');
            allElements.forEach(el => {
                const style = window.getComputedStyle(el);
                const elStyle = el.style;
                
                // Удаляем все тени
                if (style.boxShadow && style.boxShadow !== 'none') {
                    elStyle.setProperty('box-shadow', 'none', 'important');
                }
                if (style.textShadow && style.textShadow !== 'none') {
                    elStyle.setProperty('text-shadow', 'none', 'important');
                }
                
                // Удаляем все фильтры
                if (style.filter && style.filter !== 'none') {
                    elStyle.setProperty('filter', 'none', 'important');
                }
                if (style.backdropFilter && style.backdropFilter !== 'none') {
                    elStyle.setProperty('backdrop-filter', 'none', 'important');
                }
                
                // Убираем прозрачность
                if (style.opacity !== '1') {
                    elStyle.setProperty('opacity', '1', 'important');
                }
                
                // Убираем blur из transform
                if (style.transform && style.transform.includes('blur')) {
                    const newTransform = style.transform.replace(/blur\([^)]+\)/g, '');
                    elStyle.setProperty('transform', newTransform || 'none', 'important');
                }
            });
            
            // Добавляем агрессивный CSS для удаления всех эффектов
            const style = clonedDoc.createElement('style');
            style.textContent = `
                *,
                *::before,
                *::after {
                    box-shadow: none !important;
                    text-shadow: none !important;
                    filter: none !important;
                    backdrop-filter: none !important;
                    opacity: 1 !important;
                }
                
                *::before,
                *::after {
                    display: none !important;
                    content: none !important;
                }
                
                /* Убираем все overlay элементы */
                [class*="overlay"],
                [class*="Overlay"],
                .chat-sidebar-overlay {
                    display: none !important;
                    visibility: hidden !important;
                    opacity: 0 !important;
                }
                
                /* Убираем blur из transform, но сохраняем другие трансформации */
                * {
                    -webkit-filter: none !important;
                    -moz-filter: none !important;
                    -ms-filter: none !important;
                    -o-filter: none !important;
                }
            `;
            clonedDoc.head.appendChild(style);
        }
        
        async function exportChatPNG() {
            if (!currentChatId) {
                showWarning('Нет активного чата');
                return;
            }
            const chat = chats.find(c => c.id === currentChatId);
            if (!chat) {
                showError('Чат не найден');
                return;
            }
            
            try {
                // Проверяем наличие библиотеки
                if (typeof html2canvas === 'undefined') {
                    showError('Библиотека html2canvas не загружена. Проверьте подключение к интернету.');
                    return;
                }
                
                // Находим область сообщений
                const messagesArea = document.getElementById('chatMessages');
                if (!messagesArea) {
                    showError('Область сообщений не найдена');
                    return;
                }
                
                // Скрываем кнопки экспорта перед скриншотом
                const exportButtons = document.getElementById('chatExportAllButtons');
                if (exportButtons) {
                    exportButtons.style.display = 'none';
                }
                
                // Скрываем кнопки действий в сообщениях
                const allActionButtons = messagesArea.querySelectorAll('.chat-message-actions');
                allActionButtons.forEach(btn => {
                    btn.style.display = 'none';
                });
                
                // Скрываем все overlay элементы
                const overlays = document.querySelectorAll('.chat-sidebar-overlay, [class*="overlay"], [class*="Overlay"]');
                overlays.forEach(overlay => {
                    overlay.style.display = 'none';
                });
                
                // Убираем все визуальные эффекты напрямую
                removeAllVisualEffects(messagesArea);
                
                // Ждем немного для рендеринга
                await new Promise(resolve => setTimeout(resolve, 300));
                
                // Определяем правильный фон в зависимости от темы
                const backgroundColor = getBackgroundColorForExport();
                
                // Создаем скриншот с правильными настройками
                const canvas = await html2canvas(messagesArea, {
                    backgroundColor: backgroundColor,
                    scale: 2,
                    logging: false,
                    useCORS: true,
                    allowTaint: true,
                    height: messagesArea.scrollHeight,
                    width: messagesArea.scrollWidth,
                    windowHeight: messagesArea.scrollHeight,
                    windowWidth: messagesArea.scrollWidth,
                    removeContainer: false,
                    imageTimeout: 15000,
                    foreignObjectRendering: false,  // Отключаем для избежания проблем с фильтрами
                    // Игнорируем overlay элементы
                    ignoreElements: (element) => {
                        return element.classList.contains('chat-sidebar-overlay') ||
                               element.classList.contains('chat-message-actions') ||
                               element.classList.contains('chatExportAllButtons') ||
                               /overlay/i.test(element.className);
                    },
                    // Агрессивная очистка клонированного DOM
                    onclone: (clonedDoc) => {
                        cleanClonedDOM(clonedDoc);
                    }
                });
                
                // Конвертируем canvas в PNG
                canvas.toBlob((blob) => {
                    if (!blob) {
                        showError('Ошибка при создании изображения');
                        // Восстанавливаем кнопки
                        if (exportButtons) {
                            exportButtons.style.display = 'flex';
                        }
                        allActionButtons.forEach(btn => {
                            btn.style.display = 'flex';
                        });
                        return;
                    }
                    
                    const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
                    const filename = `chat_${chat.title.replace(/[^a-z0-9]/gi, '_')}_${timestamp}.png`;
                    
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = filename;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    URL.revokeObjectURL(url);
                    
                    // Восстанавливаем кнопки
                    if (exportButtons) {
                        exportButtons.style.display = 'flex';
                    }
                    allActionButtons.forEach(btn => {
                        btn.style.display = 'flex';
                    });
                }, 'image/png', 1.0); // Качество 1.0 (100%)
                
            } catch (error) {
                console.error('Ошибка при экспорте чата в PNG:', error);
                showError('Ошибка при экспорте чата в PNG: ' + error.message);
            }
        }
        
        // Функция для проверки наличия таблицы в тексте
        function hasTable(text) {
            if (!text) return false;
            
            // Быстрая проверка: если есть HTML таблица, это точно таблица
            if (text.includes('<table') || text.includes('</table>')) {
                return true;
            }
            
            const lines = text.split('\n');
            let inCodeBlock = false;
            let tableRows = [];
            let foundSeparator = false;
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                
                // Отслеживаем блоки кода
                if (line.startsWith('```')) {
                    inCodeBlock = !inCodeBlock;
                    if (inCodeBlock) {
                        tableRows = []; // Сбрасываем при входе в блок кода
                        foundSeparator = false;
                    }
                    continue;
                }
                
                // Пропускаем строки внутри блоков кода
                if (inCodeBlock) {
                    continue;
                }
                
                // Проверяем, является ли строка разделителем таблицы
                if (line.match(/^[\|\s\-\:]+$/) && line.includes('|') && line.includes('-')) {
                    // Это разделитель таблицы (|---|---|)
                    foundSeparator = true;
                    // Если перед разделителем была строка с |, это таблица
                    if (i > 0 && tableRows.length > 0) {
                        return true;
                    }
                    continue;
                }
                
                // Проверяем, является ли строка частью таблицы
                if (line.includes('|')) {
                    const cells = line.split('|').map(c => c.trim()).filter(c => c.length > 0);
                    
                    // Если есть минимум 2 ячейки (не считая пустые в начале/конце), это может быть таблица
                    if (cells.length >= 2) {
                        // Проверяем следующую строку
                        if (i < lines.length - 1) {
                            const nextLine = lines[i + 1].trim();
                            
                            // Если следующая строка - разделитель, это точно таблица
                            if (nextLine.match(/^[\|\s\-\:]+$/) && nextLine.includes('|') && nextLine.includes('-')) {
                                return true;
                            }
                            
                            // Если следующая строка тоже содержит | с ячейками, это может быть таблица
                            const nextCells = nextLine.split('|').map(c => c.trim()).filter(c => c.length > 0);
                            if (nextCells.length >= 2 && nextLine.includes('|')) {
                                // Если обе строки имеют похожее количество ячеек, это таблица
                                if (Math.abs(cells.length - nextCells.length) <= 1) {
                                    return true;
                                }
                            }
                        }
                        
                        // Сохраняем строку таблицы
                        tableRows.push(line);
                    }
                } else if (tableRows.length > 0) {
                    // Если накопили строки таблицы и встретили не-табличную строку
                    if (foundSeparator || tableRows.length >= 2) {
                        return true;
                    }
                    tableRows = [];
                    foundSeparator = false;
                } else {
                    // Сбрасываем при не-табличной строке
                    foundSeparator = false;
                }
            }
            
            // Проверяем накопленные строки в конце
            if (foundSeparator && tableRows.length > 0) {
                return true;
            }
            if (tableRows.length >= 2) {
                return true;
            }
            
            return false;
        }
        
        // Функции для экспорта отдельного сообщения
        function exportMessageJSON(messageIndex) {
            if (!currentChatId || messageIndex < 0) {
                showError('Сообщение не найдено');
                return;
            }
            const chat = chats.find(c => c.id === currentChatId);
            if (!chat || messageIndex >= chat.messages.length) {
                showError('Сообщение не найдено');
                return;
            }
            
            const msg = chat.messages[messageIndex];
            if (msg.isUser) {
                showWarning('Нельзя экспортировать собственные сообщения');
                return;
            }
            const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
            const filename = `message_${messageIndex}_${timestamp}.json`;
            
            const data = {
                message_index: messageIndex,
                chat_id: chat.id,
                chat_title: chat.title,
                timestamp: msg.timestamp,
                role: msg.isUser ? "Пользователь" : "AI",
                text: msg.text,
                files: msg.files || [],
                edited: msg.edited || false,
                edited_at: msg.edited_at || null
            };
            
            const dataStr = JSON.stringify(data, null, 2);
            downloadFile(dataStr, filename, 'application/json');
        }
        
        async function exportMessageDOCX(messageIndex) {
            if (!currentChatId || messageIndex < 0) {
                showError('Сообщение не найдено');
                return;
            }
            const chat = chats.find(c => c.id === currentChatId);
            if (!chat || messageIndex >= chat.messages.length) {
                showError('Сообщение не найдено');
                return;
            }
            
            const msg = chat.messages[messageIndex];
            if (msg.isUser) {
                showWarning('Нельзя экспортировать собственные сообщения');
                return;
            }
            
            try {
                // Отправляем одно сообщение на сервер для генерации DOCX
                const response = await fetch('/api/export-chat-docx/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        title: `Сообщение ${messageIndex + 1} из чата: ${chat.title}`,
                        chat_id: chat.id,
                        messages: [msg]  // Только одно сообщение
                    })
                });
            
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error || 'Ошибка сервера');
            }
            
                // Получаем файл как blob
                const blob = await response.blob();
                const url = window.URL.createObjectURL(blob);
                const link = document.createElement('a');
            const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
                link.href = url;
                link.download = `message_${messageIndex}_${timestamp}.docx`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                window.URL.revokeObjectURL(url);
            } catch (error) {
                console.error('Ошибка при экспорте сообщения в DOCX:', error);
                showError(`Ошибка при экспорте документа: ${error.message}`);
            }
        }
        
        // Парсинг Markdown таблицы
        function parseMarkdownTable(text) {
            const lines = text.split('\n');
            const rows = [];
            let inTable = false;
            let inCodeBlock = false;
            
            for (const line of lines) {
                // Отслеживаем блоки кода
                if (line.trim().startsWith('```')) {
                    inCodeBlock = !inCodeBlock;
                    if (inCodeBlock) {
                        inTable = false;
                    }
                    continue;
                }
                
                // Пропускаем строки внутри блоков кода
                if (inCodeBlock) {
                    continue;
                }
                
                const trimmed = line.trim();
                
                // Пропускаем разделитель строк таблицы (|---|---|)
                if (trimmed.match(/^[\|\s\-\:]+$/)) {
                    continue;
                }
                
                // Проверяем, является ли строка частью таблицы
                if (trimmed.includes('|') && trimmed.split('|').length >= 3) {
                    // Извлекаем ячейки
                    const allCells = trimmed.split('|');
                    let cells = allCells.map(cell => cell.trim());
                    
                    // Убираем пустые ячейки на краях
                    while (cells.length > 0 && cells[0] === '') {
                        cells = cells.slice(1);
                    }
                    while (cells.length > 0 && cells[cells.length - 1] === '') {
                        cells = cells.slice(0, -1);
                    }
                    
                    if (cells.length > 0) {
                        // Убираем Markdown форматирование из ячеек
                        const cleanedCells = cells.map(cell => cleanMarkdownFormatting(cell));
                        rows.push(cleanedCells);
                        inTable = true;
                    }
                } else if (inTable && trimmed.length === 0) {
                    // Пустая строка после таблицы - таблица закончилась
                    break;
                } else if (inTable && trimmed.length > 0) {
                    // Непустая строка без | после таблицы - таблица закончилась
                    break;
                }
            }
            
            return rows;
        }
        
        // Формирование CSV из таблицы с улучшенным оформлением
        // Используем точку с запятой как разделитель для российского Excel
        const CSV_SEPARATOR = ';';
        
        function formatTableAsCSV(rows, options = {}) {
            if (rows.length === 0) return '';
            
            const {
                title = '',
                metadata = {},
                groupBy = null,  // Колонка для группировки
                sortBy = null,   // Колонка для сортировки
                formatNumbers = true,
                formatCurrency = false,
                includeMetadata = false  // Включать ли метаданные в CSV
            } = options;
            
            // Определяем максимальное количество колонок
            const maxColumns = Math.max(...rows.map(row => row.length));
            
            // Нормализуем все строки до одинакового количества колонок
            let normalizedRows = rows.map(row => {
                const normalized = [...row];
                while (normalized.length < maxColumns) {
                    normalized.push('');
                }
                return normalized;
            });
            
            let csv = '';
            
            // 1. Метаданные (только если включены, и в формате, который не мешает разделению колонок)
            if (includeMetadata) {
                if (title) {
                    csv += `"Заголовок документа: ${title}"\n`;
                }
                
                if (metadata.date) {
                    const date = formatDate(metadata.date);
                    csv += `"Дата создания: ${date}"\n`;
                }
                
                if (metadata.source) {
                    csv += `"Источник: ${metadata.source}"\n`;
                }
                
                if (metadata.chatTitle) {
                    csv += `"Чат: ${metadata.chatTitle}"\n`;
                }
                
                if (title || metadata.date || metadata.source || metadata.chatTitle) {
                    csv += '\n'; // Пустая строка-разделитель
                }
            }
            
            // 2. Заголовки таблицы (первая строка)
            const headerRow = normalizedRows[0];
            const formattedHeaders = headerRow.map(header => {
                // Очищаем и форматируем заголовки
                let cleaned = cleanMarkdownFormatting(header);
                // Делаем первую букву заглавной
                if (cleaned.length > 0) {
                    cleaned = cleaned.charAt(0).toUpperCase() + cleaned.slice(1).toLowerCase();
                }
                return escapeCSV(cleaned);
            });
            csv += formattedHeaders.join(CSV_SEPARATOR) + '\n';
            
            // 3. Данные таблицы
            let dataRows = normalizedRows.slice(1);
            
            // Сортируем при необходимости
            if (sortBy !== null) {
                const sortIndex = headerRow.findIndex(h => 
                    cleanMarkdownFormatting(h).toLowerCase().includes(sortBy.toLowerCase())
                );
                if (sortIndex >= 0) {
                    dataRows.sort((a, b) => {
                        const aVal = a[sortIndex];
                        const bVal = b[sortIndex];
                        // Числовая сортировка
                        const aNum = parseFloat(aVal);
                        const bNum = parseFloat(bVal);
                        if (!isNaN(aNum) && !isNaN(bNum)) {
                            return aNum - bNum;
                        }
                        // Текстовая сортировка
                        return String(aVal).localeCompare(String(bVal), 'ru');
                    });
                }
            }
            
            // Форматируем строки данных
            dataRows.forEach((row, rowIndex) => {
                const formattedRow = row.map((cell, colIndex) => {
                    let value = cell;
                    
                    // Определяем тип данных по заголовку
                    const header = cleanMarkdownFormatting(headerRow[colIndex] || '').toLowerCase();
                    
                    // Форматируем денежные суммы (для CSV - просто число, Excel сам форматирует)
                    if (formatCurrency && (header.includes('стоимость') || 
                        header.includes('сумма') || header.includes('цена'))) {
                        const numValue = parseFloat(value);
                        if (!isNaN(numValue)) {
                            // Для CSV используем просто число, Excel сам распознает и форматирует
                            return escapeCSV(numValue.toFixed(2));
                        }
                    }
                    
                    // Форматируем числа (для CSV - просто число без форматирования)
                    if (formatNumbers && !isNaN(value) && value !== '' && !header.includes('количество')) {
                        const numValue = parseFloat(value);
                        if (!isNaN(numValue) && numValue !== 0) {
                            // Для CSV используем просто число, Excel сам распознает
                            return escapeCSV(numValue.toString());
                        }
                    }
                    
                    return escapeCSV(value);
                });
                
                csv += formattedRow.join(CSV_SEPARATOR) + '\n';
                
                // Не добавляем пустые строки между группами, чтобы не мешали разделению колонок в Excel
                // Группировка видна по одинаковым значениям в колонке группировки
            });
            
            return csv;
        }
        
        // Извлечение данных из графика для экспорта в CSV с улучшенным оформлением
        function extractChartDataForCSV(messageIndex, options = {}) {
            const messageDiv = document.querySelector(`[data-message-index="${messageIndex}"]`);
            if (!messageDiv) return null;
            
            // Ищем контейнер графика
            const chartContainer = messageDiv.querySelector('.chart-container');
            if (!chartContainer) return null;
            
            const canvas = chartContainer.querySelector('canvas');
            if (!canvas) return null;
            
            // Получаем объект графика из Chart.js
            if (typeof Chart === 'undefined' || !Chart.getChart) {
                return null;
            }
            
            const chartInstance = Chart.getChart(canvas);
            if (!chartInstance) return null;
            
            const chartType = chartInstance.config.type;
            const chartData = chartInstance.data;
            
            const {
                title = 'Экспорт данных графика',
                includeStatistics = true,  // Добавлять статистику
                sortData = false,           // Сортировать данные
                formatNumbers = true,       // Форматировать числа
                metadata = {}
            } = options;
            
            let csvRows = [];
            let csv = '';
            
            try {
                switch (chartType) {
                    case 'bar':
                    case 'line':
                        csvRows.push(['Категория', 'Значение']);
                        
                        // Собираем данные
                        let data = [];
                        if (chartData.labels && chartData.datasets && chartData.datasets[0] && chartData.datasets[0].data) {
                            chartData.labels.forEach((label, index) => {
                                const value = chartData.datasets[0].data[index];
                                if (value !== undefined && value !== null) {
                                    data.push({ label, value });
                                }
                            });
                        }
                        
                        // Сортируем по значению (убывание)
                        if (sortData && data.length > 0) {
                            data.sort((a, b) => b.value - a.value);
                        }
                        
                        // Форматируем и добавляем строки
                        data.forEach(item => {
                            // Для CSV не форматируем числа с пробелами, чтобы Excel правильно их распознавал
                            const formattedValue = formatNumbers && typeof item.value === 'number' 
                                ? item.value.toString()  // Просто число без форматирования
                                : item.value;
                            csvRows.push([item.label, formattedValue]);
                        });
                        
                            // Добавляем статистику
                            if (includeStatistics && data.length > 0) {
                                const values = data.map(d => d.value);
                                const total = values.reduce((a, b) => a + b, 0);
                                const avg = total / values.length;
                                const max = Math.max(...values);
                                const min = Math.min(...values);
                                
                                // Не добавляем пустую строку, чтобы не мешала разделению колонок
                                // Используем простые числа без форматирования для Excel
                                csvRows.push(['ИТОГО', formatNumbers ? total.toString() : total]);
                                csvRows.push(['СРЕДНЕЕ', formatNumbers ? avg.toFixed(2) : avg.toFixed(2)]);
                                csvRows.push(['МАКСИМУМ', formatNumbers ? max.toString() : max]);
                                csvRows.push(['МИНИМУМ', formatNumbers ? min.toString() : min]);
                            }
                    break;
                        
                    case 'pie':
                    case 'doughnut':
                        csvRows.push(['Категория', 'Значение', 'Процент', 'Доля']);
                        
                        let pieData = [];
                        if (chartData.labels && chartData.datasets && chartData.datasets[0] && chartData.datasets[0].data) {
                            const dataValues = chartData.datasets[0].data;
                            const total = dataValues.reduce((a, b) => (a || 0) + (b || 0), 0);
                            
                            chartData.labels.forEach((label, index) => {
                                const value = dataValues[index];
                                if (value !== undefined && value !== null) {
                                    const percent = total > 0 ? ((value / total) * 100) : 0;
                                    pieData.push({
                                        label,
                                        value,
                                        percent: percent.toFixed(2) + '%',
                                        share: (percent / 100).toFixed(4)
                                    });
                                }
                            });
                        }
                        
                        // Сортируем по значению
                        if (sortData && pieData.length > 0) {
                            pieData.sort((a, b) => b.value - a.value);
                        }
                        
                        pieData.forEach(item => {
                            // Для CSV не форматируем числа с пробелами, чтобы Excel правильно их распознавал
                            const formattedValue = formatNumbers && typeof item.value === 'number'
                                ? item.value.toString()  // Просто число без форматирования
                                : item.value;
                            csvRows.push([
                                item.label,
                                formattedValue,
                                item.percent,
                                item.share
                            ]);
                        });
                        
                        // Добавляем итоговую строку
                        if (pieData.length > 0) {
                            const total = pieData.reduce((sum, item) => sum + item.value, 0);
                            // Не добавляем пустую строку, чтобы не мешала разделению колонок
                            csvRows.push(['ИТОГО', formatNumbers ? total.toString() : total, '100%', '1.0000']);
                        }
                        break;
                        
                    default:
                        return null;
                }
                
                if (csvRows.length > 1) {
                    // Форматируем таблицу без метаданных (чтобы не мешали разделению колонок)
                    csv = formatTableAsCSV(csvRows, { 
                        formatNumbers: false, 
                        formatCurrency: false,
                        includeMetadata: false  // Не включаем метаданные в CSV
                    });
                    
                    return csv;
                }
            } catch (error) {
                console.error('Ошибка при извлечении данных графика:', error);
                return null;
            }
            
            return null;
        }
        
        function exportMessageCSV(messageIndex) {
            if (!currentChatId || messageIndex < 0) {
                showError('Сообщение не найдено');
                return;
                    }
            
            const chat = chats.find(c => c.id === currentChatId);
            if (!chat || messageIndex >= chat.messages.length) {
                showError('Сообщение не найдено');
                return;
                }
                
            const msg = chat.messages[messageIndex];
            if (msg.isUser) {
                showWarning('Нельзя экспортировать собственные сообщения');
                return;
            }
            
            const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
            let filename = `message_${messageIndex}_${timestamp}.csv`;
            let csv = '';
            
            // Получаем метаданные
            const metadata = {
                date: msg.timestamp || new Date().toISOString(),
                source: 'Альфа-Ассистент',
                chatTitle: chat.title
            };
            
            // 1. Проверяем наличие графика в сообщении
            const chartData = extractChartDataForCSV(messageIndex, {
                title: `График из чата: ${chat.title}`,
                includeStatistics: true,
                sortData: true,
                formatNumbers: true,
                metadata: metadata
            });
            
            if (chartData) {
                csv = chartData;
                filename = `chart_${messageIndex}_${timestamp}.csv`;
            } else {
                // 2. Проверяем наличие таблицы в тексте
                const text = msg.text || '';
                const tableRows = parseMarkdownTable(text);
                
                // Отладочная информация
                console.log('Парсинг таблицы для CSV:', {
                    textLength: text.length,
                    tableRowsCount: tableRows.length,
                    firstRows: tableRows.slice(0, 3)
                });
                
                if (tableRows.length > 0) {
                    // Определяем, есть ли денежные колонки
                    const headers = tableRows[0].map(h => cleanMarkdownFormatting(h).toLowerCase());
                    const hasCurrency = headers.some(h => 
                        h.includes('стоимость') || h.includes('сумма') || h.includes('цена')
                    );
                    
                    // Определяем колонку для группировки (если есть "Папка" или "Категория")
                    const groupByColumn = headers.find(h => 
                        h.includes('папка') || h.includes('категория') || h.includes('группа')
                    );
                    
                    // Определяем колонку для сортировки (название или товар)
                    const sortByColumn = headers.find(h => 
                        h.includes('название') || h.includes('товар') || h.includes('имя')
                    );
                    
                    csv = formatTableAsCSV(tableRows, {
                        title: `Таблица из чата: ${chat.title}`,
                        metadata: metadata,
                        groupBy: groupByColumn || null,
                        sortBy: sortByColumn || null,
                        formatNumbers: true,
                        formatCurrency: hasCurrency,
                        includeMetadata: false  // Не включаем метаданные, чтобы не мешали разделению колонок
                    });
                } else {
                    // 3. Если нет таблицы и графика - экспортируем как текстовое сообщение
                    const msgTimestamp = formatDate(msg.timestamp || new Date().toISOString());
                    csv = 'Время;Роль;Сообщение;Файлы;Отредактировано\n';
                    const files = (msg.files || []).map(f => typeof f === 'string' ? f : (f.name || f)).join('; ');
                    csv += `${escapeCSV(msgTimestamp)};${escapeCSV('AI')};${escapeCSV(msg.text || '')};${escapeCSV(files)};${escapeCSV(msg.edited ? 'Да' : 'Нет')}\n`;
                }
            }
            
            // Добавляем UTF-8 BOM для Excel
            const BOM = '\uFEFF';
            const csvWithBOM = BOM + csv;
            
            // Создаем и скачиваем файл
            const blob = new Blob([csvWithBOM], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        }
        
        async function exportMessagePNG(messageIndex) {
            if (!currentChatId || messageIndex < 0) {
                showError('Сообщение не найдено');
                return;
            }
            const chat = chats.find(c => c.id === currentChatId);
            if (!chat || messageIndex >= chat.messages.length) {
                showError('Сообщение не найдено');
                return;
            }
            
            const msg = chat.messages[messageIndex];
            if (msg.isUser) {
                showWarning('Нельзя экспортировать собственные сообщения');
                return;
            }
            
            try {
                // Проверяем наличие библиотеки
                if (typeof html2canvas === 'undefined') {
                    showError('Библиотека html2canvas не загружена. Проверьте подключение к интернету.');
                    return;
                }
                
                // Находим элемент сообщения в DOM
                const messagesArea = document.getElementById('chatMessages');
                if (!messagesArea) {
                    showError('Область сообщений не найдена');
                    return;
                }
                
                const messageDivs = messagesArea.querySelectorAll('.chat-message');
                if (messageIndex >= messageDivs.length) {
                    showError('Сообщение не найдено в DOM');
                    return;
                }
                
                const messageDiv = messageDivs[messageIndex];
                if (!messageDiv) {
                    showError('Элемент сообщения не найден');
                    return;
                }
                
                // Скрываем кнопки действий перед скриншотом
                const actionsDiv = messageDiv.querySelector('.chat-message-actions');
                if (actionsDiv) {
                    actionsDiv.style.display = 'none';
                }
                
                // Убираем все визуальные эффекты напрямую
                removeAllVisualEffects(messageDiv);
                
                // Ждем немного для рендеринга
                await new Promise(resolve => setTimeout(resolve, 300));
                
                // Определяем правильный фон в зависимости от темы
                const backgroundColor = getBackgroundColorForExport();
                
                // Создаем скриншот элемента с правильными настройками
                const canvas = await html2canvas(messageDiv, {
                    backgroundColor: backgroundColor,
                    scale: 2,
                    logging: false,
                    useCORS: true,
                    allowTaint: true,
                    width: messageDiv.scrollWidth,
                    height: messageDiv.scrollHeight,
                    removeContainer: false,
                    imageTimeout: 15000,
                    foreignObjectRendering: false,  // Отключаем для избежания проблем с фильтрами
                    // Игнорируем кнопки действий
                    ignoreElements: (element) => {
                        return element.classList.contains('chat-message-actions') ||
                               element.classList.contains('chat-sidebar-overlay') ||
                               /overlay/i.test(element.className);
                    },
                    // Агрессивная очистка клонированного DOM
                    onclone: (clonedDoc) => {
                        cleanClonedDOM(clonedDoc);
                    }
                });
                
                // Конвертируем canvas в PNG
                canvas.toBlob((blob) => {
                    if (!blob) {
                        showError('Ошибка при создании изображения');
                        // Восстанавливаем кнопки
                        if (actionsDiv) {
                            actionsDiv.style.display = 'flex';
                        }
                        return;
                    }
                    
                    const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
                    const filename = `message_${messageIndex}_${timestamp}.png`;
                    
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = filename;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    URL.revokeObjectURL(url);
                    
                    // Восстанавливаем кнопки
                    if (actionsDiv) {
                        actionsDiv.style.display = 'flex';
                    }
                }, 'image/png', 1.0); // Качество 1.0 (100%)
                
            } catch (error) {
                console.error('Ошибка при экспорте в PNG:', error);
                showError('Ошибка при экспорте в PNG: ' + error.message);
            }
        }
        
        function showEditMessageModal(messageIndex) {
            editingMessageIndex = messageIndex;
            const chat = chats.find(c => c.id === currentChatId);
            if (!chat || messageIndex < 0 || messageIndex >= chat.messages.length) {
                showError('Сообщение не найдено');
                return;
            }
            
            const message = chat.messages[messageIndex];
            if (!message.isUser) {
                showWarning('Можно редактировать только свои сообщения');
                return;
            }
            
            const textarea = document.getElementById('editMessageText');
            if (textarea) {
                textarea.value = message.text || '';
            }
            
            const modal = document.getElementById('editMessageModal');
            if (modal) {
                modal.style.display = 'flex';
            }
        }
        
        function closeEditMessageModal() {
            editingMessageIndex = -1;
            const modal = document.getElementById('editMessageModal');
            if (modal) {
                modal.style.display = 'none';
            }
        }
        
        function saveEditedMessage() {
            if (editingMessageIndex < 0) {
                closeEditMessageModal();
                return;
            }
            
            const textarea = document.getElementById('editMessageText');
            const newText = textarea ? textarea.value.trim() : '';
            
            if (!newText) {
                showWarning('Сообщение не может быть пустым');
                return;
            }
            
            const chat = chats.find(c => c.id === currentChatId);
            if (!chat || editingMessageIndex >= chat.messages.length) {
                showError('Ошибка: чат или сообщение не найдены');
                closeEditMessageModal();
                return;
            }
            
            // Обновляем сообщение
            chat.messages[editingMessageIndex].text = newText;
            chat.messages[editingMessageIndex].edited = true;
            chat.messages[editingMessageIndex].edited_at = new Date().toISOString();
            
            // Сохраняем
            saveChats();
            
            // Перезагружаем чат
            loadChat(currentChatId, false);
            closeEditMessageModal();
            
            console.log('Сообщение успешно отредактировано');
        }
        
        // Логирование действий AI в localStorage
        function logAIAction(action, data) {
            try {
                const currentUser = JSON.parse(localStorage.getItem('currentUser') || '{}');
                const email = currentUser.email || '';
                if (!email) return;
                
                const key = `ai_actions_${email}`;
                const actions = JSON.parse(localStorage.getItem(key) || '[]');
                
                actions.push({
                    action: action,
                    data: data,
                    timestamp: new Date().toISOString(),
                    chat_id: currentChatId
                });
                
                // Храним только последние 1000 действий
                if (actions.length > 1000) {
                    actions.shift();
                }
                
                localStorage.setItem(key, JSON.stringify(actions));
            } catch (error) {
                console.error('Ошибка при логировании действия AI:', error);
            }
        }
        
        // Обработка параметра action из URL (быстрые действия)
        function handleQuickAction() {
            const urlParams = new URLSearchParams(window.location.search);
            const action = urlParams.get('action');
            
            if (!action) return;
            
            // Определяем сообщение на основе действия
            let message = '';
            switch(action) {
                case 'analyze':
                    message = 'Проанализируй мои данные и покажи основные показатели';
                    break;
                case 'report':
                    message = 'Создай отчет по моему бизнесу';
                    break;
                case 'plan':
                    message = 'Помоги мне спланировать дела на ближайшее время';
                    break;
                case 'question':
                    message = '';
                    // Для вопроса не добавляем автоматическое сообщение - пользователь сам введет
                    return;
                default:
                    return;
            }
            
            // Если сообщение пустое, ничего не делаем
            if (!message) return;
            
            // Ждем полной загрузки чата и затем автоматически отправляем сообщение
            setTimeout(() => {
                // Создаем новый чат, если его нет
                if (!currentChatId || chats.length === 0) {
                    createNewChat();
                }
                
                // Устанавливаем сообщение в поле ввода
                const input = document.getElementById('chatInput');
                if (input) {
                    input.value = message;
                    
                    // Автоматически отправляем сообщение
                    setTimeout(() => {
                        sendMessage();
                    }, 300); // Небольшая задержка для гарантии загрузки
                }
                
                // Удаляем параметр из URL, чтобы при обновлении страницы не отправлялось повторно
                window.history.replaceState({}, document.title, window.location.pathname);
            }, 500);
        }
        
        // Инициализация
        function initChat() {
            // Перезагружаем чаты, избранное и закрепленные для текущего пользователя
            chats = getUserChats();
            
            // Очищаем filesData из загруженных чатов (на случай если они еще там есть)
            chats = chats.map(chat => ({
                ...chat,
                messages: chat.messages.map(msg => {
                    const { filesData, ...msgWithoutFilesData } = msg;
                    return msgWithoutFilesData;
                })
            }));
            
            favorites = getUserFavorites();
            pinnedChats = getUserPinnedChats();
            
            renderChatHistory();
            if (chats.length > 0) {
                loadChat(chats[0].id, true); // Всегда скроллим вниз при загрузке страницы
            } else {
                // Показываем сообщения с возможностями если нет чатов
                renderCapabilityMessages();
                // Скрываем кнопки экспорта если нет чатов
                toggleChatExportButtons();
            }
            
            // Восстанавливаем активные запросы
            restoreActiveRequests();
            
            // Обрабатываем быстрые действия из URL
            handleQuickAction();
        }

        // Создание нового чата
        function createNewChat() {
            const chatId = 'chat_' + Date.now();
            const newChat = {
                id: chatId,
                title: 'Новый чат',
                messages: [],
                createdAt: new Date().toISOString()
            };
            chats.unshift(newChat);
            saveChats();
            loadChat(chatId);
            renderChatHistory();
        }

        // Сохранение чатов (без данных файлов для экономии места в localStorage)
        function saveChats() {
            // Очищаем filesData из всех сообщений перед сохранением
            const chatsToSave = chats.map(chat => ({
                ...chat,
                messages: chat.messages.map(msg => {
                    const { filesData, ...msgWithoutFilesData } = msg;
                    return msgWithoutFilesData;
                })
            }));
            saveUserChats(chatsToSave);
        }
        
        // Функция для очистки старых данных файлов из localStorage (вызывать один раз)
        function cleanupOldFileData() {
            try {
                const currentUser = JSON.parse(localStorage.getItem('currentUser') || '{}');
                const email = currentUser.email || '';
                if (!email) return;
                
                const key = `chats_${email}`;
                const savedChats = JSON.parse(localStorage.getItem(key) || '[]');
                
                if (savedChats.length > 0) {
                    const cleanedChats = savedChats.map(chat => ({
                        ...chat,
                        messages: chat.messages.map(msg => {
                            const { filesData, ...msgWithoutFilesData } = msg;
                            return msgWithoutFilesData;
                        })
                    }));
                    
                    localStorage.setItem(key, JSON.stringify(cleanedChats));
                    console.log('Очищены старые данные файлов из localStorage');
                }
            } catch (e) {
                console.error('Ошибка при очистке старых данных:', e);
            }
        }

        // Показать/скрыть кнопку экспорта всего чата
        function toggleChatExportButtons() {
            const exportButton = document.getElementById('chatExportAllButton');
            if (exportButton) {
                if (currentChatId && chats.find(c => c.id === currentChatId)) {
                    exportButton.style.display = 'block';
                } else {
                    exportButton.style.display = 'none';
                }
            }
        }
        
        // Показать модальное окно экспорта чата
        function showExportChatModal() {
            const modal = document.getElementById('exportChatModal');
            if (modal) {
                modal.style.display = 'flex';
            }
        }
        
        // Закрыть модальное окно экспорта чата
        function closeExportChatModal() {
            const modal = document.getElementById('exportChatModal');
            if (modal) {
                modal.style.display = 'none';
            }
        }
        
        // Закрытие модального окна при клике вне его
        window.addEventListener('click', function(event) {
            const exportModal = document.getElementById('exportChatModal');
            if (exportModal && event.target === exportModal) {
                closeExportChatModal();
            }
        });
        
        // Сообщения с возможностями чата
        const capabilityMessages = [
            'Покажи баланс моих счетов',
            'Какие у меня задолженности по налогам?',
            'Сколько я потратил в этом месяце?',
            'Покажи список сотрудников',
            'Какие товары есть в инвентаризации?',
            'Создай встречу на завтра в 15:00',
            'Покажи все события в календаре',
            'Какие документы у меня загружены?'
        ];
        
        // Отображение сообщений с возможностями
        function renderCapabilityMessages() {
            const messagesArea = document.getElementById('chatMessages');
            if (!messagesArea) return;
            
            messagesArea.innerHTML = `
                <div class="chat-ai-widget-main" id="chatWelcome">
                    <div class="chat-ai-icon-main">
                        <span class="chat-ai-icon-text-main">AI</span>
                    </div>
                    <div class="chat-ai-prompt">С чего начнём, Босс?</div>
                </div>
                <div class="chat-capability-messages" id="chatCapabilityMessages">
                    ${capabilityMessages.map((message, index) => `
                        <div class="chat-capability-message" onclick="sendCapabilityMessage('${message.replace(/'/g, "\\'")}')">
                            ${message}
                        </div>
                    `).join('')}
                </div>
            `;
        }
        
        // Отправка сообщения из возможностей
        function sendCapabilityMessage(messageText) {
            const input = document.getElementById('chatInput');
            input.value = messageText;
            sendMessage();
        }
        
        // Делаем функцию глобальной для вызова из onclick
        window.sendCapabilityMessage = sendCapabilityMessage;
        
        // Модальное окно с примерами вопросов
        function toggleSuggestionsModal() {
            const modal = document.getElementById('suggestionsModal');
            const modalBody = document.getElementById('suggestionsModalBody');
            
            if (modal.style.display === 'none' || !modal.style.display) {
                // Показываем модальное окно
                modal.style.display = 'flex';
                
                // Заполняем модальное окно примерами вопросов
                modalBody.innerHTML = capabilityMessages.map((message, index) => `
                    <div class="suggestion-modal-item" onclick="selectSuggestion('${message.replace(/'/g, "\\'")}')">
                        ${message}
                    </div>
                `).join('');
            } else {
                // Скрываем модальное окно
                modal.style.display = 'none';
            }
        }
        
        function selectSuggestion(messageText) {
            const input = document.getElementById('chatInput');
            input.value = messageText;
            toggleSuggestionsModal(); // Закрываем модальное окно
            input.focus(); // Фокусируемся на поле ввода
        }
        
        // Делаем функции глобальными для вызова из onclick
        window.toggleSuggestionsModal = toggleSuggestionsModal;
        window.selectSuggestion = selectSuggestion;
        
        // Закрытие модального окна при клике вне его
        document.addEventListener('click', function(event) {
            const modal = document.getElementById('suggestionsModal');
            const modalContent = document.querySelector('.suggestions-modal-content');
            if (modal && event.target === modal) {
                toggleSuggestionsModal();
            }
        });
        
        // Загрузка чата
        function loadChat(chatId, scrollToBottom = true) {
            currentChatId = chatId;
            const chat = chats.find(c => c.id === chatId);
            if (!chat) return;

            const messagesArea = document.getElementById('chatMessages');
            const welcomeDiv = document.getElementById('chatWelcome');

            if (chat.messages.length === 0) {
                // Показываем сообщения с возможностями для нового чата
                renderCapabilityMessages();
            } else {
                messagesArea.innerHTML = '';
                chat.messages.forEach((msg, index) => {
                    addMessageToUI(msg.text, msg.isUser, msg.files || null, msg.filesData || null, false, index);
                });
                
                // Скроллим вниз только если нужно
                if (scrollToBottom) {
                    // Используем requestAnimationFrame для синхронизации с рендерингом
                    requestAnimationFrame(() => {
                        requestAnimationFrame(() => {
                            scrollToBottomMessages(true);
                        });
                    });
                    
                    // Используем несколько попыток для надежности
                    setTimeout(() => {
                        scrollToBottomMessages(true);
                    }, 50);
                    setTimeout(() => {
                        scrollToBottomMessages(true);
                    }, 200);
                    setTimeout(() => {
                        scrollToBottomMessages(true);
                    }, 500);
                }
            }
            
            updateActiveChat();
            
            // Показываем кнопки экспорта
            toggleChatExportButtons();
            
            // Пытаемся найти историю чата на сервере
            loadChatHistoryFromServer();
        }
        
        async function loadChatHistoryFromServer() {
            try {
                const currentUser = JSON.parse(localStorage.getItem('currentUser') || '{}');
                const email = currentUser.email || '';
                if (!email || !currentChatId) return;
                
                // Показываем индикатор загрузки, если функция доступна
                if (typeof showLoading === 'function') {
                    showLoading('Загрузка истории чата...');
                }
                
                const response = await fetch(`/api/chat-history/?email=${encodeURIComponent(email)}`);
                const data = await response.json();
                if (data.success && data.history.length > 0) {
                    const historyItem = data.history.find(h => h.chat_id === currentChatId);
                    if (historyItem) {
                        currentChatHistoryId = historyItem.id;
                    }
                }
            } catch (error) {
                console.error('Ошибка при загрузке истории с сервера:', error);
            } finally {
                // Скрываем индикатор загрузки
                if (typeof hideLoading === 'function') {
                    hideLoading();
                }
            }
        }
        
        // Функция для обновления текста сообщения без перерисовки всего чата
        function updateMessageText(messageIndex, newText, autoScroll = true) {
            const messagesArea = document.getElementById('chatMessages');
            if (!messagesArea) return;
            
            const messageDiv = messagesArea.querySelector(`[data-message-index="${messageIndex}"]`);
            if (messageDiv) {
                const messageTextDiv = messageDiv.querySelector('.chat-message-text');
                if (messageTextDiv) {
                    if (newText === 'Думаю...') {
                        // Для сообщения "Думаю..." просто обновляем текст без markdown
                        messageTextDiv.textContent = newText;
                    } else {
                        // Для других сообщений используем markdown
                        messageTextDiv.innerHTML = markdownToHTML(newText);
                    }
                    
                    // Автоматически прокручиваем вниз после обновления текста
                    // Используем requestAnimationFrame для плавности и после полного рендеринга DOM
                    if (autoScroll) {
                        // Первая попытка через requestAnimationFrame для синхронизации с рендерингом
                        requestAnimationFrame(() => {
                            requestAnimationFrame(() => {
                                scrollToBottomMessages(true);
                            });
                        });
                        
                        // Дополнительные попытки с задержками для надежности (50ms, 200ms)
                        setTimeout(() => {
                            scrollToBottomMessages(true);
                        }, 50);
                        setTimeout(() => {
                            scrollToBottomMessages(true);
                        }, 200);
                    }
                }
            }
        }
        
        // Функция для скролла вниз области сообщений
        function scrollToBottomMessages(force = false) {
            const messagesArea = document.getElementById('chatMessages');
            if (!messagesArea) return;
            
            const scrollHeight = messagesArea.scrollHeight;
            const clientHeight = messagesArea.clientHeight;
            const scrollTop = messagesArea.scrollTop;
            
            // Проверяем, находится ли пользователь внизу (с небольшим допуском в 100px)
            const isNearBottom = scrollHeight - scrollTop - clientHeight < 100;
            
            // Прокручиваем только если принудительно или если пользователь уже внизу
            if (force || isNearBottom) {
                // Используем прямой установкой scrollTop для мгновенной прокрутки
                // Это важно для потокового обновления текста
                messagesArea.scrollTop = scrollHeight;
            }
        }
        
        // Отправка сообщения
        function sendMessage() {
            const input = document.getElementById('chatInput');
            const message = input.value.trim();
            
            // Проверяем, есть ли сообщение или прикрепленные файлы
            if (!message && (!attachedFiles || attachedFiles.length === 0)) {
                return;
            }

            if (!currentChatId) {
                createNewChat();
            }

            const chat = chats.find(c => c.id === currentChatId);
            if (!chat) {
                console.error('Чат не найден');
                return;
            }
            
            // Сохраняем копию прикрепленных файлов перед обработкой
            const filesToSend = attachedFiles ? [...attachedFiles] : [];
            
            // Проверка размера файлов перед отправкой
            const MAX_FILE_SIZE = 20 * 1024 * 1024; // 20 MB на файл
            const MAX_TOTAL_SIZE = 40 * 1024 * 1024; // 40 MB общий размер
            
            let totalSize = 0;
            for (const file of filesToSend) {
                if (file.size > MAX_FILE_SIZE) {
                    showWarning(`Файл "${file.name}" слишком большой (${formatFileSize(file.size)}). Максимальный размер файла: ${formatFileSize(MAX_FILE_SIZE)}`);
                    return;
                }
                totalSize += file.size;
            }
            
            if (totalSize > MAX_TOTAL_SIZE) {
                showWarning(`Общий размер файлов (${formatFileSize(totalSize)}) превышает допустимый лимит (${formatFileSize(MAX_TOTAL_SIZE)}). Пожалуйста, уменьшите количество или размер файлов.`);
                return;
            }
            
            // Показываем индикатор загрузки на кнопке отправки
            const sendButton = document.getElementById('chatSendBtn');
            if (sendButton && typeof showButtonLoading === 'function') {
                showButtonLoading(sendButton, 'Отправить');
            }

            // Добавляем сообщение пользователя
            const userMessage = {
                text: message || (filesToSend.length > 0 ? 'Прикрепленные файлы' : ''),
                isUser: true,
                timestamp: new Date().toISOString(),
                files: filesToSend.map(f => ({
                    name: f.name,
                    size: f.size,
                    type: f.type
                }))
            };
            
            // Обрабатываем файлы для отправки (НЕ сохраняем base64 в localStorage!)
            if (filesToSend.length > 0) {
                Promise.all(filesToSend.map(fileObj => {
                    return new Promise((resolve, reject) => {
                        const reader = new FileReader();
                        reader.onload = function(e) {
                            resolve({
                                name: fileObj.name,
                                size: fileObj.size,
                                type: fileObj.type,
                                data: e.target.result  // Используем только для отправки на сервер
                            });
                        };
                        reader.onerror = function(e) {
                            reject(e);
                        };
                        reader.readAsDataURL(fileObj.file);
                    });
                })).then(filesData => {
                    // Сохраняем сообщение БЕЗ filesData (чтобы не переполнить localStorage)
                    // filesData используется только для отправки на сервер
                    chat.messages.push(userMessage);
                    
                    // Обновляем заголовок чата (первое сообщение)
                    const displayText = message || (filesToSend.length > 0 ? filesToSend[0].name : '');
                    if (chat.title === 'Новый чат' && displayText.length > 30) {
                        chat.title = displayText.substring(0, 30) + '...';
                    } else if (chat.title === 'Новый чат') {
                        chat.title = displayText;
                    }

                    // Добавляем временный ответ AI (пока загружается)
                    const aiMessage = {
                        text: 'Думаю...',
                        isUser: false,
                        timestamp: new Date().toISOString()
                    };
                    chat.messages.push(aiMessage);
                    
                    // Сохраняем чат БЕЗ данных файлов
                    saveChats();
                    loadChat(currentChatId, true); // Всегда скроллим вниз при отправке
                    
                    // Отправляем запрос к AI с файлами (filesData не сохраняется в localStorage)
                    sendMessageToAI(message, chat.messages.slice(0, -1), currentChatId, filesData);
                    
                    // Дополнительный скролл после загрузки
                    setTimeout(() => {
                        scrollToBottomMessages(true);
                    }, 200);
                    
                    input.value = '';
                    attachedFiles = [];
                    renderAttachedFiles();
                    
                    // Скрываем индикатор загрузки на кнопке
                    if (sendButton && typeof hideButtonLoading === 'function') {
                        hideButtonLoading(sendButton);
                    }
                }).catch(error => {
                    console.error('Ошибка при чтении файлов:', error);
                    const errorMessage = error.message || 'Неизвестная ошибка';
                    showError(`Произошла ошибка при обработке файлов:\n\n${errorMessage}\n\nПроверьте:\n- Размер файлов (рекомендуется до 10MB)\n- Формат файлов\n- Консоль браузера для деталей`);
                    
                    // Скрываем индикатор загрузки на кнопке при ошибке
                    if (sendButton && typeof hideButtonLoading === 'function') {
                        hideButtonLoading(sendButton);
                    }
                });
            } else {
                // Нет файлов, просто отправляем сообщение
                chat.messages.push(userMessage);
                
                // Обновляем заголовок чата (первое сообщение)
                if (chat.title === 'Новый чат' && message.length > 30) {
                    chat.title = message.substring(0, 30) + '...';
                } else if (chat.title === 'Новый чат') {
                    chat.title = message;
                }

                // Добавляем временный ответ AI (пока загружается)
                const aiMessage = {
                    text: 'Думаю...',
                    isUser: false,
                    timestamp: new Date().toISOString()
                };
                chat.messages.push(aiMessage);
                saveChats();
                loadChat(currentChatId, true); // Всегда скроллим вниз при отправке
                
                // Отправляем запрос к AI
                sendMessageToAI(message, chat.messages.slice(0, -1), currentChatId, []);
                
                // Дополнительный скролл после загрузки
                setTimeout(() => {
                    scrollToBottomMessages(true);
                }, 200);
                
                input.value = '';
                
                // Скрываем индикатор загрузки на кнопке (будет скрыт после получения ответа)
                // Индикатор скрывается в функции sendMessageToAI после обработки ответа
            }
        }

        // Функция для получения данных пользователя из localStorage
        function getUserDataForAI() {
            const currentUser = JSON.parse(localStorage.getItem('currentUser') || '{}');
            const email = currentUser.email || '';
            if (!email) return {};
            
            // Загружаем папки инвентаризации для сопоставления ID с названиями
            const inventoryFolders = JSON.parse(localStorage.getItem(`inventoryFolders_${email}`) || '[]');
            const folderMap = {}; // Маппинг folderId -> folderName
            inventoryFolders.forEach(folder => {
                folderMap[folder.id] = folder.name;
            });
            
            // Обрабатываем инвентаризацию: заменяем folderId на название папки
            const inventory = JSON.parse(localStorage.getItem(`inventory_${email}`) || '[]');
            const processedInventory = inventory.map(item => {
                const folderId = item.folderId || item.folder;
                const folderName = folderId ? (folderMap[folderId] || folderId) : 'Без категории';
                return {
                    ...item,
                    folderName: folderName, // Добавляем название папки
                    folder: folderName // Заменяем ID на название
                };
            });
            
            return {
                receipts: JSON.parse(localStorage.getItem(`receipts_${email}`) || '[]'),
                inventory: processedInventory, // Используем обработанную инвентаризацию с названиями папок
                inventoryFolders: inventoryFolders, // Добавляем папки для контекста
                employees: JSON.parse(localStorage.getItem(`employees_${email}`) || '[]'),
                calendarEvents: JSON.parse(localStorage.getItem(`calendarEvents_${email}`) || '[]'),
                taxesData: JSON.parse(localStorage.getItem('taxesData') || '{}'),
                utilitiesData: JSON.parse(localStorage.getItem('utilitiesData') || '{}'),
                documents: JSON.parse(localStorage.getItem(`documents_${email}`) || '[]'),
                accountBalance: parseFloat(localStorage.getItem('accountBalance') || '0'),
                accountBalance2: parseFloat(localStorage.getItem('accountBalance2') || '0')
            };
        }

        // Функция для создания события в календаре
        async function createCalendarEventFromAI(eventData) {
            console.log('=== createCalendarEventFromAI вызвана ===');
            console.log('Данные события для создания:', eventData);
            
            // Проверяем обязательные поля
            if (!eventData.title || !eventData.date) {
                console.error('❌ Недостаточно данных для создания события:', eventData);
                console.error('title:', eventData.title, 'date:', eventData.date);
                return false;
            }
            
            const currentUser = JSON.parse(localStorage.getItem('currentUser') || '{}');
            const email = currentUser.email || '';
            if (!email) {
                console.error('❌ Email не найден');
                return false;
            }
            
            try {
                const key = `calendarEvents_${email}`;
                const events = JSON.parse(localStorage.getItem(key) || '[]');
                
                // Форматируем дату в ISO формат, если нужно
                let eventDate = eventData.date;
                console.log('Исходная дата:', eventDate);
                
                if (eventDate) {
                    // Если дата уже в ISO формате с T
                    if (eventDate.includes('T')) {
                        // Проверяем, есть ли время
                        if (eventDate.match(/T\d{2}:\d{2}/)) {
                            // Есть время, конвертируем в полный ISO
                            try {
                                const dateObj = new Date(eventDate);
                                if (!isNaN(dateObj.getTime())) {
                                    eventDate = dateObj.toISOString();
                                }
                            } catch (e) {
                                console.warn('Ошибка парсинга даты с T:', e);
                            }
                        } else {
                            // Нет времени, добавляем 12:00
                            eventDate = eventDate + 'T12:00:00';
                            const dateObj = new Date(eventDate);
                            if (!isNaN(dateObj.getTime())) {
                                eventDate = dateObj.toISOString();
                            }
                        }
                    } else if (eventDate.includes(' ')) {
                        // Дата с пробелом (например, "2024-12-25 15:00")
                        eventDate = eventDate.replace(' ', 'T');
                        if (!eventDate.includes(':')) {
                            eventDate += ':00';
                        }
                        const dateObj = new Date(eventDate);
                        if (!isNaN(dateObj.getTime())) {
                            eventDate = dateObj.toISOString();
                        }
                    } else {
                        // Только дата без времени
                        const dateObj = new Date(eventDate + 'T12:00:00');
                        if (!isNaN(dateObj.getTime())) {
                            eventDate = dateObj.toISOString();
                        }
                    }
                } else {
                    // Если дата не указана, используем сегодняшнюю дату в 12:00
                    const today = new Date();
                    today.setHours(12, 0, 0, 0);
                    eventDate = today.toISOString();
                }
                
                console.log('Обработанная дата:', eventDate);
                
                const newEvent = {
                    id: eventData.id || Date.now().toString(),
                    title: eventData.title || 'Новое событие',
                    date: eventDate,
                    description: eventData.description || '',
                    notified: false
                };
                
                console.log('Создаваемое событие:', newEvent);
                
                events.push(newEvent);
                localStorage.setItem(key, JSON.stringify(events));
                console.log('✅ Событие сохранено в localStorage:', newEvent);
                
                // Добавить принудительный триггер storage события для других вкладок
                const storageEvent = new StorageEvent('storage', {
                    key: key,
                    newValue: JSON.stringify(events),
                    url: window.location.href
                });
                window.dispatchEvent(storageEvent);
                
                // Отправляем кастомное событие для обновления календаря на текущей странице
                window.dispatchEvent(new CustomEvent('calendarUpdated'));
                
                // Обновляем календарь, если он открыт в другом окне
                if (window.opener && typeof window.opener.loadNotifications === 'function') {
                    window.opener.loadNotifications();
                }
                if (window.opener && typeof window.opener.renderCalendar === 'function') {
                    window.opener.renderCalendar();
                }
                
                console.log('✅ Событие успешно создано!');
                return true;
            } catch (error) {
                console.error('❌ Ошибка при создании события:', error);
                return false;
            }
        }
        
        // Функция для удаления события из календаря
        async function deleteCalendarEventFromAI(eventData) {
            console.log('=== deleteCalendarEventFromAI вызвана ===');
            console.log('Данные события для удаления:', eventData);
            
            const currentUser = JSON.parse(localStorage.getItem('currentUser') || '{}');
            const email = currentUser.email || '';
            if (!email) {
                console.error('Email не найден');
                return false;
            }
            
            try {
                const key = `calendarEvents_${email}`;
                const events = JSON.parse(localStorage.getItem(key) || '[]');
                console.log('Всего событий в календаре:', events.length);
                console.log('Ищем событие с ID:', eventData.id);
                
                // Ищем событие по ID
                const eventIndex = events.findIndex(e => String(e.id) === String(eventData.id));
                if (eventIndex === -1) {
                    console.error('Событие не найдено! Искомый ID:', eventData.id);
                    console.log('Доступные события:', events.map(e => ({ id: e.id, title: e.title })));
                    return false;
                }
                
                console.log('Событие найдено на позиции:', eventIndex);
                console.log('Удаляем событие:', events[eventIndex]);
                
                // Удаляем событие
                events.splice(eventIndex, 1);
                localStorage.setItem(key, JSON.stringify(events));
                console.log('✅ Событие удалено из localStorage');
                
                // Добавить принудительный триггер storage события для других вкладок
                const storageEvent = new StorageEvent('storage', {
                    key: key,
                    newValue: JSON.stringify(events),
                    url: window.location.href
                });
                window.dispatchEvent(storageEvent);
                
                // Отправляем кастомное событие для обновления календаря на текущей странице
                window.dispatchEvent(new CustomEvent('calendarUpdated'));
                
                // Обновляем календарь, если он открыт в другом окне
                if (window.opener && typeof window.opener.loadNotifications === 'function') {
                    window.opener.loadNotifications();
                }
                if (window.opener && typeof window.opener.renderCalendar === 'function') {
                    window.opener.renderCalendar();
                }
                
                return true;
            } catch (error) {
                console.error('Ошибка при удалении события:', error);
                return false;
            }
        }
        
        // Функция для обновления события в календаре
        async function updateCalendarEventFromAI(eventData) {
            console.log('=== updateCalendarEventFromAI вызвана ===');
            console.log('Данные события для обновления:', eventData);
            
            const currentUser = JSON.parse(localStorage.getItem('currentUser') || '{}');
            const email = currentUser.email || '';
            if (!email) {
                console.error('Email не найден');
                return false;
            }
            
            try {
                const key = `calendarEvents_${email}`;
                const events = JSON.parse(localStorage.getItem(key) || '[]');
                console.log('Всего событий в календаре:', events.length);
                console.log('Ищем событие с ID:', eventData.id);
                
                // Ищем событие по ID
                const event = events.find(e => String(e.id) === String(eventData.id));
                if (!event) {
                    console.error('Событие не найдено! Искомый ID:', eventData.id);
                    console.log('Доступные события:', events.map(e => ({ id: e.id, title: e.title })));
                    return false;
                }
                
                console.log('Событие найдено:', event);
                console.log('Текущие данные события:', {
                    title: event.title,
                    date: event.date,
                    description: event.description
                });
                
                console.log('Поля для обновления:', {
                    title: eventData.title,
                    date: eventData.date,
                    description: eventData.description
                });
                
                // Обновляем только указанные поля (проверяем наличие ключа в объекте)
                // Если поле присутствует в eventData, обновляем его (даже если это пустая строка)
                let updated = false;
                
                if ('title' in eventData && eventData.title !== null && eventData.title !== undefined) {
                    const oldTitle = event.title || '';
                    const newTitle = String(eventData.title).trim();
                    event.title = newTitle;
                    updated = true;
                    console.log('=== ОБНОВЛЕНИЕ НАЗВАНИЯ СОБЫТИЯ ===');
                    console.log('  Старое название:', oldTitle);
                    console.log('  Новое название:', newTitle);
                    console.log('✅ Название успешно обновлено');
                } else {
                    console.log('Название не указано для обновления (ключ отсутствует или null)');
                }
                
                // Обновляем дату, если она указана (проверяем наличие ключа)
                if ('date' in eventData && eventData.date !== null && eventData.date !== undefined && eventData.date !== '') {
                    updated = true;
                    let eventDate = String(eventData.date).trim();
                    console.log('=== ОБНОВЛЕНИЕ ДАТЫ СОБЫТИЯ ===');
                    console.log('Получена дата для обновления:', eventDate);
                    console.log('Тип даты:', typeof eventData.date);
                    console.log('Текущая дата события:', event.date);
                    
                    try {
                        let parsedDate = null;
                        const oldDate = event.date;
                        
                        // Нормализуем формат даты
                        // Убираем лишние пробелы
                        eventDate = eventDate.replace(/\s+/g, ' ').trim();
                        
                        // Если дата в формате YYYY-MM-DDTHH:mm (без секунд и временной зоны)
                        if (/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}$/.test(eventDate)) {
                            // Добавляем секунды и миллисекунды для правильного парсинга
                            parsedDate = new Date(eventDate + ':00');
                            console.log('Парсинг формата YYYY-MM-DDTHH:mm:', eventDate + ':00');
                        }
                        // Если дата в формате YYYY-MM-DDTHH:mm:ss
                        else if (/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/.test(eventDate)) {
                            parsedDate = new Date(eventDate);
                            console.log('Парсинг формата YYYY-MM-DDTHH:mm:ss:', eventDate);
                        }
                        // Если дата в формате YYYY-MM-DD HH:mm (с пробелом)
                        else if (/^\d{4}-\d{2}-\d{2}\s+\d{2}:\d{2}/.test(eventDate)) {
                            eventDate = eventDate.replace(/\s+/, 'T') + ':00';
                            parsedDate = new Date(eventDate);
                            console.log('Парсинг формата YYYY-MM-DD HH:mm:', eventDate);
                        }
                        // Если только дата YYYY-MM-DD, добавляем время 12:00
                        else if (/^\d{4}-\d{2}-\d{2}$/.test(eventDate)) {
                            parsedDate = new Date(eventDate + 'T12:00:00');
                            console.log('Парсинг формата YYYY-MM-DD (добавлено время 12:00):', eventDate + 'T12:00:00');
                        }
                        // Пытаемся распарсить как есть (для полных ISO строк)
                        else {
                            parsedDate = new Date(eventDate);
                            console.log('Парсинг как есть:', eventDate);
                        }
                        
                        if (parsedDate && !isNaN(parsedDate.getTime())) {
                            const newDateISO = parsedDate.toISOString();
                            event.date = newDateISO;
                            console.log('✅ ДАТА УСПЕШНО ОБНОВЛЕНА!');
                            console.log('  Старая дата:', oldDate);
                            console.log('  Новая дата (ISO):', newDateISO);
                            console.log('  Новая дата (читаемый формат):', parsedDate.toLocaleString('ru-RU', {
                                year: 'numeric',
                                month: 'long',
                                day: 'numeric',
                                hour: '2-digit',
                                minute: '2-digit'
                            }));
                        } else {
                            console.error('❌ НЕВАЛИДНАЯ ДАТА - не удалось распарсить:', eventDate);
                            console.error('  Попытка парсинга вернула:', parsedDate);
                        }
                    } catch (e) {
                        console.error('❌ ОШИБКА при парсинге даты:', e);
                        console.error('  Исходная дата:', eventDate);
                        console.error('  Стек ошибки:', e.stack);
                    }
                } else {
                    console.log('Дата не указана для обновления (ключ отсутствует или значение пустое)');
                }
                
                // Обновляем описание, если оно указано (включая пустую строку для очистки)
                // Проверяем наличие ключа, чтобы отличить "не указано" от "пустая строка"
                if ('description' in eventData && eventData.description !== null && eventData.description !== undefined) {
                    updated = true;
                    const oldDescription = event.description || '';
                    // Описание может быть пустой строкой (для очистки), поэтому не используем trim() если это важно
                    // Но для обычных случаев используем trim() чтобы убрать лишние пробелы
                    let newDescription = String(eventData.description);
                    // Если это не пустая строка, обрезаем пробелы
                    if (newDescription.trim() !== '') {
                        newDescription = newDescription.trim();
                    }
                    event.description = newDescription;
                    console.log('=== ОБНОВЛЕНИЕ ОПИСАНИЯ СОБЫТИЯ ===');
                    console.log('  Старое описание:', oldDescription);
                    console.log('  Новое описание:', newDescription);
                    console.log('  Длина нового описания:', newDescription.length);
                    console.log('✅ Описание успешно обновлено');
                } else {
                    console.log('Описание не указано для обновления (ключ отсутствует или null/undefined)');
                    console.log('  eventData.description:', eventData.description);
                    console.log('  "description" in eventData:', 'description' in eventData);
                }
                event.notified = false; // Сбрасываем уведомление при изменении
                
                if (!updated) {
                    console.warn('⚠️ Ни одно поле не было обновлено! Проверьте данные:', eventData);
                    console.warn('Проверка полей:', {
                        hasTitle: 'title' in eventData,
                        titleValue: eventData.title,
                        titleType: typeof eventData.title,
                        hasDate: 'date' in eventData,
                        dateValue: eventData.date,
                        hasDescription: 'description' in eventData,
                        descriptionValue: eventData.description
                    });
                }
                
                // Сохраняем обновленные события
                console.log('=== СОХРАНЕНИЕ СОБЫТИЯ ===');
                console.log('Обновленное событие перед сохранением:', JSON.stringify(event, null, 2));
                localStorage.setItem(key, JSON.stringify(events));
                console.log('✅ События сохранены в localStorage');
                
                // Добавить принудительный триггер storage события для других вкладок
                const storageEvent = new StorageEvent('storage', {
                    key: key,
                    newValue: JSON.stringify(events),
                    url: window.location.href
                });
                window.dispatchEvent(storageEvent);
                
                // Проверяем, что дата действительно обновилась
                const savedEvents = JSON.parse(localStorage.getItem(key) || '[]');
                const savedEvent = savedEvents.find(e => String(e.id) === String(eventData.id));
                if (savedEvent) {
                    console.log('=== ПРОВЕРКА СОХРАНЕННОГО СОБЫТИЯ ===');
                    console.log('  ID:', savedEvent.id);
                    console.log('  Название:', savedEvent.title);
                    console.log('  Дата:', savedEvent.date);
                    console.log('  Описание:', savedEvent.description);
                } else {
                    console.error('❌ ОШИБКА: Событие не найдено после сохранения!');
                }
                
                // Отправляем кастомное событие для обновления календаря на текущей странице
                window.dispatchEvent(new CustomEvent('calendarUpdated'));
                
                // Обновляем календарь, если он открыт в другом окне
                if (window.opener && typeof window.opener.loadNotifications === 'function') {
                    window.opener.loadNotifications();
                }
                if (window.opener && typeof window.opener.renderCalendar === 'function') {
                    window.opener.renderCalendar();
                }
                
                return true;
            } catch (error) {
                console.error('Ошибка при обновлении события:', error);
                return false;
            }
        }

        // Хранилище активных запросов для проверки статуса
        const activeRequests = new Map();
        
        // Функция для периодической проверки статуса запроса
        async function checkRequestStatus(requestId, chatId) {
            try {
                const response = await fetch(`/api/chat-status/${requestId}/`);
                const data = await response.json();
                
                if (!data.success) {
                    console.error('Ошибка при проверке статуса:', data.error);
                    return;
                }
                
                const chat = chats.find(c => c.id === chatId);
                if (!chat || chat.messages.length === 0) {
                    return;
                }
                
                const lastMessage = chat.messages[chat.messages.length - 1];
                if (!lastMessage || lastMessage.isUser) {
                    return;
                }
                
                if (data.status === 'processing' || data.status === 'pending') {
                    // Запрос еще обрабатывается, продолжаем проверку
                    lastMessage.text = 'Думаю...';
                    saveChats();
                    
                    // Обновляем только текст сообщения без перерисовки всего чата
                    const messageIndex = chat.messages.length - 1;
                    updateMessageText(messageIndex, 'Думаю...', false); // Не скроллим при "Думаю..."
                    
                    // Продолжаем проверку через 2 секунды
                    setTimeout(() => checkRequestStatus(requestId, chatId), 2000);
                    return;
                }
                
                if (data.status === 'completed') {
                    // Запрос завершен
                    console.log('Ответ получен:', data);
                    console.log('Действие в ответе:', data.action);
                    lastMessage.text = data.response || 'Ответ получен';
                    
                    // Обрабатываем действия (например, создание или обновление события)
                    if (data.action && Object.keys(data.action).length > 0) {
                        console.log('✅ Действие найдено, начинаем обработку:', data.action);
                        
                        // Логируем действие AI
                        if (typeof logAIAction === 'function') {
                            logAIAction(data.action.action, data.action);
                        }
                        
                        if (data.action.action === 'create_event') {
                            console.log('Создание события:', data.action);
                            const eventCreated = await createCalendarEventFromAI(data.action);
                            if (eventCreated) {
                                // Форматируем дату для читаемого отображения
                                let dateStr = data.action.date || '';
                                try {
                                    const dateObj = new Date(data.action.date);
                                    if (!isNaN(dateObj.getTime())) {
                                        dateStr = dateObj.toLocaleDateString('ru-RU', {
                                            year: 'numeric',
                                            month: 'long',
                                            day: 'numeric',
                                            hour: '2-digit',
                                            minute: '2-digit'
                                        });
                                    }
                                } catch (e) {
                                    // Используем исходную дату, если не удалось распарсить
                                }
                                lastMessage.text += '\n\n✅ Событие "' + data.action.title + '" добавлено в календарь на ' + dateStr + '!';
                            } else {
                                lastMessage.text += '\n\n⚠️ Не удалось добавить событие в календарь.';
                            }
                        } else if (data.action.action === 'update_event') {
                            const eventUpdated = await updateCalendarEventFromAI(data.action);
                            if (eventUpdated) {
                                const updates = [];
                                if ('title' in data.action && data.action.title !== null && data.action.title !== undefined) {
                                    updates.push('название');
                                }
                                if ('date' in data.action && data.action.date !== null && data.action.date !== undefined && data.action.date !== '') {
                                    updates.push('дату');
                                }
                                if ('description' in data.action && data.action.description !== null && data.action.description !== undefined) {
                                    updates.push('описание');
                                }
                                
                                if (updates.length > 0) {
                                    let updateMessage = '✅ Событие обновлено!';
                                    if (updates.length === 1) {
                                        updateMessage += ' Изменено: ' + updates[0] + '.';
                                    } else if (updates.length === 2) {
                                        updateMessage += ' Изменено: ' + updates.join(' и ') + '.';
                                    } else {
                                        updateMessage += ' Изменено: ' + updates.slice(0, -1).join(', ') + ' и ' + updates[updates.length - 1] + '.';
                                    }
                                    lastMessage.text += '\n\n' + updateMessage;
                                }
                            }
                        } else if (data.action.action === 'delete_event') {
                            console.log('Удаление события:', data.action);
                            const eventDeleted = await deleteCalendarEventFromAI(data.action);
                            console.log('Результат удаления события:', eventDeleted);
                            if (eventDeleted) {
                                lastMessage.text += '\n\n✅ Событие удалено из календаря!';
                            } else {
                                lastMessage.text += '\n\n⚠️ Не удалось удалить событие. Возможно, событие не найдено.';
                            }
                        } else if (data.action.action === 'delete_document') {
                            const docDeleted = await deleteDocumentFromAI(data.action);
                            if (docDeleted) {
                                lastMessage.text += '\n\n✅ Документ удален!';
                            }
                        } else if (data.action.action === 'rename_document') {
                            const docRenamed = await renameDocumentFromAI(data.action);
                            if (docRenamed) {
                                lastMessage.text += '\n\n✅ Документ переименован!';
                            }
                        } else if (data.action.action === 'send_support_message') {
                            const messageSent = await sendSupportMessageFromAI(data.action);
                            if (messageSent) {
                                lastMessage.text += '\n\n✅ Сообщение отправлено в поддержку!';
                            }
                        }
                    } else {
                        console.warn('⚠️ Действие отсутствует или пустое в ответе');
                    }
                    
                    saveChats();
                    renderChatHistory();
                    
                    // Обновляем только текст сообщения без перерисовки всего чата
                    const messageIndex = chat.messages.length - 1;
                    updateMessageText(messageIndex, lastMessage.text, true);
                    
                    activeRequests.delete(requestId);
                    return;
                }
                
                if (data.status === 'failed') {
                    // Запрос завершился с ошибкой
                    lastMessage.text = 'Ошибка: ' + (data.error || 'Неизвестная ошибка');
                    saveChats();
                    renderChatHistory();
                    
                    // Обновляем только текст сообщения без перерисовки всего чата
                    const messageIndex = chat.messages.length - 1;
                    updateMessageText(messageIndex, lastMessage.text, true);
                    
                    activeRequests.delete(requestId);
                    return;
                }
            } catch (error) {
                console.error('Ошибка при проверке статуса запроса:', error);
                // Продолжаем проверку даже при ошибке
                setTimeout(() => checkRequestStatus(requestId, chatId), 5000);
            }
        }
        
        // Функция для отправки сообщения в AI через API
        async function sendMessageToAI(message, chatHistory, chatId, attachedFilesData = []) {
            try {
                // Получаем данные пользователя
                const userData = getUserDataForAI();
                
                // Подготавливаем файлы для отправки
                // Убираем ограничение размера - сервер сам обработает большие файлы
                const filesToSend = attachedFilesData.map(file => ({
                    name: file.name || '',
                    type: file.type || '',
                    size: file.size || 0,
                    data: file.data || '' // Отправляем полные данные файла
                }));
                
                const response = await fetch('/api/chat/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        message: message,
                        history: chatHistory,
                        userData: userData,
                        files: filesToSend
                    })
                });

                const data = await response.json();
                
                // Находим чат и обновляем последнее сообщение AI
                const chat = chats.find(c => c.id === chatId);
                if (chat && chat.messages.length > 0) {
                    const lastMessage = chat.messages[chat.messages.length - 1];
                    if (!lastMessage.isUser) {
                        if (data.success && data.request_id) {
                            // Запрос принят в обработку, начинаем проверку статуса
                            const requestId = data.request_id;
                            activeRequests.set(requestId, { chatId, startTime: Date.now() });
                            
                            // Сохраняем request_id в сообщении для возможности восстановления
                            lastMessage.requestId = requestId;
                            lastMessage.text = 'Думаю...';
                            saveChats();
                            
                            // Обновляем только текст сообщения без перерисовки всего чата
                            const messageIndex = chat.messages.length - 1;
                            updateMessageText(messageIndex, 'Думаю...', false); // Не скроллим при "Думаю..."
                            
                            // Начинаем периодическую проверку статуса
                            checkRequestStatus(requestId, chatId);
                        } else if (data.success && data.response) {
                            // Старый формат (синхронный ответ) - для обратной совместимости
                            lastMessage.text = data.response;
                            
                            // Обрабатываем действия (например, создание или обновление события)
                            if (data.action) {
                                // Логируем действие AI
                                if (typeof logAIAction === 'function') {
                                    logAIAction(data.action.action, data.action);
                                }
                                
                                if (data.action.action === 'create_event') {
                                    const eventCreated = await createCalendarEventFromAI(data.action);
                                    if (eventCreated) {
                                        lastMessage.text += '\n\n✅ Событие "' + data.action.title + '" добавлено в календарь!';
                                    }
                                } else if (data.action.action === 'update_event') {
                                    console.log('=== ОБНОВЛЕНИЕ СОБЫТИЯ ===');
                                    console.log('Полные данные действия:', JSON.stringify(data.action, null, 2));
                                    console.log('ID события:', data.action.id);
                                    console.log('Новое название:', data.action.title, '(присутствует:', 'title' in data.action, ')');
                                    console.log('Новая дата:', data.action.date, '(присутствует:', 'date' in data.action, ')');
                                    console.log('Новое описание:', data.action.description, '(присутствует:', 'description' in data.action, ')');
                                    
                                    const eventUpdated = await updateCalendarEventFromAI(data.action);
                                    console.log('Результат обновления:', eventUpdated);
                                    
                                    if (eventUpdated) {
                                        const updates = [];
                                        // Проверяем наличие ключей, а не только значений
                                        // Название может быть пустой строкой (для очистки)
                                        if ('title' in data.action && data.action.title !== null && data.action.title !== undefined) {
                                            updates.push('название');
                                        }
                                        if ('date' in data.action && data.action.date !== null && data.action.date !== undefined && data.action.date !== '') {
                                            updates.push('дату');
                                        }
                                        // Описание может быть пустой строкой (для очистки)
                                        if ('description' in data.action && data.action.description !== null && data.action.description !== undefined) {
                                            updates.push('описание');
                                        }
                                        console.log('Список обновлений:', updates);
                                        
                                        if (updates.length > 0) {
                                            let updateMessage = '✅ Событие обновлено!';
                                            if (updates.length === 1) {
                                                updateMessage += ' Изменено: ' + updates[0] + '.';
                                            } else if (updates.length === 2) {
                                                updateMessage += ' Изменено: ' + updates.join(' и ') + '.';
                                            } else {
                                                updateMessage += ' Изменено: ' + updates.slice(0, -1).join(', ') + ' и ' + updates[updates.length - 1] + '.';
                                            }
                                            lastMessage.text += '\n\n' + updateMessage;
                                        } else {
                                            lastMessage.text += '\n\n⚠️ Событие найдено, но не было указано что изменить. Проверьте формат команды.';
                                        }
                                    } else {
                                        lastMessage.text += '\n\n❌ Не удалось обновить событие. Возможно, событие не найдено.';
                                    }
                                }
                            }
                        } else {
                            lastMessage.text = 'Извините, произошла ошибка: ' + (data.error || 'Неизвестная ошибка');
                        }
                        lastMessage.timestamp = new Date().toISOString();
                        saveChats();
                        renderChatHistory();
                        
                        // Обновляем только текст сообщения без перерисовки всего чата
                        const messageIndex = chat.messages.length - 1;
                        updateMessageText(messageIndex, lastMessage.text, true); // Автоматически скроллит вниз
                    }
                }
                
                // Скрываем индикатор загрузки на кнопке отправки
                const sendButton = document.getElementById('chatSendBtn');
                if (sendButton && typeof hideButtonLoading === 'function') {
                    hideButtonLoading(sendButton);
                }
            } catch (error) {
                // Используем улучшенную обработку ошибок
                if (typeof handleError === 'function') {
                    handleError(error, {
                        function: 'sendMessageToAI',
                        chatId: chatId,
                        message: message
                    }, {
                        showModal: false,
                        silent: false
                    });
                } else {
                    console.error('Ошибка при отправке сообщения:', error);
                }
                
                // Обновляем сообщение об ошибке
                const chat = chats.find(c => c.id === chatId);
                if (chat && chat.messages.length > 0) {
                    const lastMessage = chat.messages[chat.messages.length - 1];
                    if (!lastMessage.isUser) {
                        const errorMessage = typeof handleError === 'function' 
                            ? handleError(error, {}, { silent: true }).userMessage
                            : 'Ошибка подключения к AI. Убедитесь, что Ollama запущен.';
                        lastMessage.text = errorMessage;
                        lastMessage.timestamp = new Date().toISOString();
                        saveChats();
                        
                        // Обновляем только текст сообщения без перерисовки всего чата
                        const messageIndex = chat.messages.length - 1;
                        updateMessageText(messageIndex, lastMessage.text, true); // Автоматически скроллит вниз
                    }
                }
                
                // Скрываем индикатор загрузки на кнопке отправки при ошибке
                const sendButton = document.getElementById('chatSendBtn');
                if (sendButton && typeof hideButtonLoading === 'function') {
                    hideButtonLoading(sendButton);
                }
            }
        }

        // Функция для преобразования markdown в HTML
        function markdownToHTML(text) {
            if (!text) return '';
            
            let html = text;
            
            // Сначала обрабатываем многострочный код (чтобы не трогать его содержимое)
            const codeBlocks = [];
            html = html.replace(/```([\s\S]*?)```/g, (match, code) => {
                const id = `CODEBLOCK_${codeBlocks.length}`;
                const escapedCode = code.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                codeBlocks.push(`<pre class="markdown-code-block"><code>${escapedCode}</code></pre>`);
                return id;
            });
            
            // Обрабатываем инлайн код
            const inlineCodes = [];
            html = html.replace(/`([^`\n]+)`/g, (match, code) => {
                const id = `INLINECODE_${inlineCodes.length}`;
                const escapedCode = code.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                inlineCodes.push(`<code class="markdown-inline-code">${escapedCode}</code>`);
                return id;
            });
            
            // Экранируем HTML-теги для безопасности
            html = html.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
            
            // Восстанавливаем инлайн код
            inlineCodes.forEach((code, index) => {
                html = html.replace(`INLINECODE_${index}`, code);
            });
            
            // Жирный текст: **текст** или __текст__
            html = html.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
            html = html.replace(/__([^_]+)__/g, '<strong>$1</strong>');
            
            // Курсив: *текст* или _текст_ (упрощенная версия без lookbehind для совместимости)
            html = html.replace(/(^|[^*])\*([^*\n]+?)\*([^*]|$)/g, '$1<em>$2</em>$3');
            html = html.replace(/(^|[^_])_([^_\n]+?)_([^_]|$)/g, '$1<em>$2</em>$3');
            
            // Зачеркнутый текст: ~~текст~~
            html = html.replace(/~~([^~]+)~~/g, '<del>$1</del>');
            
            // Восстанавливаем блоки кода
            codeBlocks.forEach((code, index) => {
                html = html.replace(`CODEBLOCK_${index}`, code);
            });
            
            // Заголовки: # Заголовок, ## Подзаголовок и т.д.
            html = html.replace(/^### (.+)$/gm, '<h3 class="markdown-h3">$1</h3>');
            html = html.replace(/^## (.+)$/gm, '<h2 class="markdown-h2">$1</h2>');
            html = html.replace(/^# (.+)$/gm, '<h1 class="markdown-h1">$1</h1>');
            
            // Списки: - элемент или * элемент
            const lines = html.split('\n');
            let inList = false;
            const processedLines = [];
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                const listMatch = line.match(/^[\*\-\+]\s+(.+)$/);
                if (listMatch) {
                    if (!inList) {
                        inList = true;
                        processedLines.push('<ul class="markdown-list"><li>' + listMatch[1] + '</li>');
                    } else {
                        processedLines.push('<li>' + listMatch[1] + '</li>');
                    }
                } else {
                    if (inList) {
                        inList = false;
                        processedLines.push('</ul>');
                    }
                    processedLines.push(line);
                }
            }
            if (inList) {
                processedLines.push('</ul>');
            }
            html = processedLines.join('\n');
            
            // Нумерованные списки: 1. элемент
            inList = false;
            const processedLines2 = [];
            const lines2 = html.split('\n');
            for (let i = 0; i < lines2.length; i++) {
                const line = lines2[i];
                const listMatch = line.match(/^\d+\.\s+(.+)$/);
                if (listMatch) {
                    if (!inList) {
                        inList = true;
                        processedLines2.push('<ol class="markdown-list"><li>' + listMatch[1] + '</li>');
                    } else {
                        processedLines2.push('<li>' + listMatch[1] + '</li>');
                    }
                } else {
                    if (inList) {
                        inList = false;
                        processedLines2.push('</ol>');
                    }
                    processedLines2.push(line);
                }
            }
            if (inList) {
                processedLines2.push('</ol>');
            }
            html = processedLines2.join('\n');
            
            // Ссылки: [текст](url)
            html = html.replace(/\[([^\]]+)\]\(([^\)]+)\)/g, '<a href="$2" target="_blank" rel="noopener" class="markdown-link">$1</a>');
            
            // Графики: обработка команд
            // Новый подход: простые команды [CHART_RECEIPTS:тип], [CHART_INVENTORY:тип] и т.д.
            // Старый подход: [CHART:тип:данные_json] - для обратной совместимости
            const chartBlocks = [];
            
            // Функция для автоматического создания графика из данных пользователя
            function createChartFromUserData(dataType, chartType) {
                const userData = getUserDataForAI();
                let chartData = null;
                
                try {
                    switch(dataType.toUpperCase()) {
                        case 'RECEIPTS':
                        case 'ЧЕКИ':
                            if (!userData.receipts || userData.receipts.length === 0) {
                                return null;
                            }
                            
                            // Определяем тип графика по chartType
                            const isLineChart = chartType && (chartType.toLowerCase() === 'line');
                            
                            if (isLineChart) {
                                // Для линейного графика группируем по датам
                                const operationsByDate = {};
                                userData.receipts.forEach(receipt => {
                                    let dateKey = 'Неизвестно';
                                    if (receipt.date) {
                                        try {
                                            const date = new Date(receipt.date);
                                            dateKey = date.toLocaleDateString('ru-RU', { day: '2-digit', month: '2-digit' });
                                        } catch (e) {
                                            dateKey = receipt.date.split('T')[0] || receipt.date.split(' ')[0] || 'Неизвестно';
                                        }
                                    }
                                    const amount = receipt.amount || 0;
                                    if (!operationsByDate[dateKey]) {
                                        operationsByDate[dateKey] = 0;
                                    }
                                    operationsByDate[dateKey] += Math.abs(amount);
                                });
                                
                                const dates = Object.keys(operationsByDate).sort();
                                const amounts = dates.map(date => operationsByDate[date]);
                                
                                if (dates.length === 0) return null;
                                
                                chartData = {
                                    labels: dates,
                                    data: amounts,
                                    label: 'Сумма операций'
                                };
                            } else {
                                // Для других графиков группируем по типам операций
                                const operationsByType = {};
                                userData.receipts.forEach(receipt => {
                                    const opType = receipt.operationType || 'Операция';
                                    const amount = receipt.amount || 0;
                                    if (!operationsByType[opType]) {
                                        operationsByType[opType] = 0;
                                    }
                                    operationsByType[opType] += Math.abs(amount);
                                });
                                
                                const opLabels = Object.keys(operationsByType);
                                const opData = opLabels.map(label => operationsByType[label]);
                                
                                if (opLabels.length === 0) return null;
                                
                                chartData = {
                                    labels: opLabels,
                                    data: opData,
                                    label: 'Сумма операций'
                                };
                            }
                            break;
                            
                        case 'INVENTORY':
                        case 'ИНВЕНТАРИЗАЦИЯ':
                            if (!userData.inventory || userData.inventory.length === 0) {
                                return null;
                            }
                            
                            // Определяем тип графика
                            const isInventoryPie = chartType && (chartType.toLowerCase() === 'pie' || chartType.toLowerCase() === 'doughnut');
                            
                            if (isInventoryPie) {
                                // Для круговых диаграмм группируем по категориям (папкам)
                                const categories = {};
                                userData.inventory.forEach(item => {
                                    // Используем folderName если есть, иначе folder, иначе 'Без категории'
                                    const cat = item.folderName || item.folder || (item.folderId ? 'Папка ' + item.folderId : 'Без категории');
                                    const quantity = item.quantity || 0;
                                    const price = item.price || 0;
                                    const value = quantity * price;
                                    
                                    if (!categories[cat]) {
                                        categories[cat] = 0;
                                    }
                                    categories[cat] += value;
                                });
                                
                                const catLabels = Object.keys(categories);
                                const catData = catLabels.map(label => categories[label]);
                                
                                if (catLabels.length === 0) return null;
                                
                                chartData = {
                                    labels: catLabels,
                                    data: catData,
                                    label: 'Стоимость'
                                };
                            } else {
                                // Для других графиков (bar, horizontal) используем НАЗВАНИЯ ТОВАРОВ
                                const itemsData = [];
                                userData.inventory.forEach(item => {
                                    const itemName = item.name || 'Без названия';
                                    const quantity = item.quantity || 0;
                                    const price = item.price || 0;
                                    const value = quantity * price;
                                    
                                    if (itemName && value > 0) {
                                        itemsData.push({
                                            name: itemName,
                                            value: value,
                                            category: item.folderName || item.folder || 'Без категории'
                                        });
                                    }
                                });
                                
                                // Сортируем по стоимости (от большего к меньшему)
                                itemsData.sort((a, b) => b.value - a.value);
                                
                                // Берем топ-10 товаров для графика
                                const topItems = itemsData.slice(0, 10);
                                
                                if (topItems.length === 0) return null;
                                
                                chartData = {
                                    labels: topItems.map(item => item.name), // ИСПОЛЬЗУЕМ НАЗВАНИЯ ТОВАРОВ
                                    data: topItems.map(item => item.value),
                                    label: 'Стоимость'
                                };
                            }
                            break;
                            
                        case 'EMPLOYEES':
                        case 'СОТРУДНИКИ':
                            if (!userData.employees || userData.employees.length === 0) {
                                return null;
                            }
                            
                            const empLabels = userData.employees.map(emp => emp.fio || 'Не указано');
                            const empData = userData.employees.map(emp => emp.salary || 0);
                            
                            chartData = {
                                labels: empLabels,
                                data: empData,
                                label: 'Зарплата'
                            };
                            break;
                            
                        case 'TAXES':
                        case 'НАЛОГИ':
                            if (!userData.taxesData || Object.keys(userData.taxesData).length === 0) {
                                return null;
                            }
                            
                            const taxNames = {
                                profit: 'Налог на прибыль',
                                vat: 'НДС',
                                property: 'Налог на имущество',
                                insurance: 'Страховые взносы'
                            };
                            
                            const taxLabels = [];
                            const taxData = [];
                            
                            Object.keys(userData.taxesData).forEach(key => {
                                const debt = userData.taxesData[key]?.debt || 0;
                                if (debt > 0) {
                                    taxLabels.push(taxNames[key] || key);
                                    taxData.push(debt);
                                }
                            });
                            
                            if (taxLabels.length === 0) return null;
                            
                            chartData = {
                                labels: taxLabels,
                                data: taxData,
                                label: 'Задолженность'
                            };
                            break;
                            
                        case 'UTILITIES':
                        case 'КОММУНАЛЬНЫЕ':
                            if (!userData.utilitiesData || Object.keys(userData.utilitiesData).length === 0) {
                                return null;
                            }
                            
                            const utilNames = {
                                electricity: 'Электричество',
                                water: 'Водоснабжение',
                                heating: 'Отопление',
                                waste: 'Вывоз ТКО',
                                security: 'Охранные услуги',
                                internet: 'Интернет'
                            };
                            
                            const utilLabels = [];
                            const utilData = [];
                            
                            Object.keys(userData.utilitiesData).forEach(key => {
                                const debt = userData.utilitiesData[key]?.debt || 0;
                                if (debt > 0) {
                                    utilLabels.push(utilNames[key] || key);
                                    utilData.push(debt);
                                }
                            });
                            
                            if (utilLabels.length === 0) return null;
                            
                            chartData = {
                                labels: utilLabels,
                                data: utilData,
                                label: 'Задолженность'
                            };
                            break;
                            
                        case 'BALANCE':
                        case 'БАЛАНС':
                            chartData = {
                                labels: ['Счет 1', 'Счет 2', 'Общий баланс'],
                                data: [
                                    userData.accountBalance || 0,
                                    userData.accountBalance2 || 0,
                                    (userData.accountBalance || 0) + (userData.accountBalance2 || 0)
                                ],
                                label: 'Баланс'
                            };
                            break;
                            
                        default:
                            return null;
                    }
                    
                    return chartData;
                } catch (error) {
                    console.error('Ошибка при создании графика из данных:', error);
                    return null;
                }
            }
            
            // Обработка простых команд [CHART_ТИП_ДАННЫХ:тип_графика]
            // Это ПРИОРИТЕТНЫЙ подход - обрабатывается первым
            const simpleChartRegex = /\[CHART_(RECEIPTS|INVENTORY|EMPLOYEES|TAXES|UTILITIES|BALANCE|ЧЕКИ|ИНВЕНТАРИЗАЦИЯ|СОТРУДНИКИ|НАЛОГИ|КОММУНАЛЬНЫЕ|БАЛАНС):(\w+)\]/gi;
            html = html.replace(simpleChartRegex, (match, dataType, chartType) => {
                const id = `CHART_${chartBlocks.length}_${Date.now()}`;
                
                try {
                    // Создаем график из данных пользователя
                    const chartData = createChartFromUserData(dataType, chartType);
                    
                    if (!chartData) {
                        const dataTypeName = {
                            'RECEIPTS': 'чеки',
                            'INVENTORY': 'инвентаризация',
                            'EMPLOYEES': 'сотрудники',
                            'TAXES': 'налоги',
                            'UTILITIES': 'коммунальные услуги',
                            'BALANCE': 'балансы'
                        }[dataType.toUpperCase()] || dataType;
                        return `<div class="chart-container error">Недостаточно данных для создания графика (${dataTypeName})</div>`;
                    }
                    
                    // Валидация данных
                    if (!chartData.labels || !Array.isArray(chartData.labels) || chartData.labels.length === 0) {
                        return `<div class="chart-container error">Ошибка: отсутствуют метки для графика</div>`;
                    }
                    
                    if (!chartData.data || !Array.isArray(chartData.data) || chartData.data.length === 0) {
                        return `<div class="chart-container error">Ошибка: отсутствуют данные для графика</div>`;
                    }
                    
                    // Выравниваем длины массивов
                    const minLength = Math.min(chartData.labels.length, chartData.data.length);
                    chartData.labels = chartData.labels.slice(0, minLength);
                    chartData.data = chartData.data.slice(0, minLength);
                    
                    chartBlocks.push({ id, type: chartType.toLowerCase(), data: chartData });
                    return `<div id="chart_container_${id}" class="chart-container loading"></div>`;
                } catch (error) {
                    console.error('Ошибка при создании графика из данных:', error);
                    return `<div class="chart-container error">Ошибка создания графика: ${error.message}</div>`;
                }
            });
            
            // Функция для очистки и исправления JSON (для обратной совместимости)
            function cleanAndParseJSON(jsonString) {
                if (!jsonString) return null;
                
                // Убираем лишние пробелы
                let cleaned = jsonString.trim();
                
                // Убираем все запятые в начале строки
                while (cleaned.startsWith(',')) {
                    cleaned = cleaned.substring(1).trim();
                }
                
                // Убираем лишние закрывающие скобки в конце (если они не являются частью JSON)
                // Считаем баланс скобок
                let openBraces = (cleaned.match(/\{/g) || []).length;
                let closeBraces = (cleaned.match(/\}/g) || []).length;
                let openBrackets = (cleaned.match(/\[/g) || []).length;
                let closeBrackets = (cleaned.match(/\]/g) || []).length;
                
                // Убираем лишние закрывающие скобки
                while (closeBrackets > openBrackets && cleaned.endsWith(']')) {
                    cleaned = cleaned.slice(0, -1).trim();
                    closeBrackets--;
                }
                while (closeBraces > openBraces && cleaned.endsWith('}')) {
                    cleaned = cleaned.slice(0, -1).trim();
                    closeBraces--;
                }
                
                // Пробуем найти JSON объект внутри строки (самый надежный способ)
                const jsonObjectMatch = cleaned.match(/\{[\s\S]*\}/);
                if (jsonObjectMatch) {
                    cleaned = jsonObjectMatch[0];
                } else {
                    // Если нет объекта, ищем массив
                    const jsonArrayMatch = cleaned.match(/\[[\s\S]*\]/);
                    if (jsonArrayMatch) {
                        cleaned = jsonArrayMatch[0];
                    }
                }
                
                // Исправляем распространенные ошибки
                // Убираем запятые перед закрывающими скобками
                cleaned = cleaned.replace(/,(\s*[}\]])/g, '$1');
                
                // Исправляем двойные запятые
                cleaned = cleaned.replace(/,+/g, ',');
                
                // Исправляем запятые после открывающих скобок
                cleaned = cleaned.replace(/([{\[])\s*,/g, '$1');
                
                // Исправляем незакрытые строки (добавляем кавычки если нужно)
                // Но только для ключей, не для значений
                cleaned = cleaned.replace(/([{,]\s*)([a-zA-Z_][a-zA-Z0-9_]*)\s*:/g, '$1"$2":');
                
                // Пробуем парсить
                try {
                    const parsed = JSON.parse(cleaned);
                    return parsed;
                } catch (e1) {
                    // Если не получилось, пробуем обернуть в фигурные скобки
                    if (!cleaned.startsWith('{') && !cleaned.startsWith('[')) {
                        try {
                            return JSON.parse('{' + cleaned + '}');
                        } catch (e2) {
                            // Пробуем найти массив и создать объект
                            const arrayMatch = cleaned.match(/\[[\s\S]*\]/);
                            if (arrayMatch) {
                                try {
                                    const arr = JSON.parse(arrayMatch[0]);
                                    // Если это массив, создаем объект с data
                                    // Пробуем найти labels в исходной строке
                                    const labelsMatch = jsonString.match(/"labels"\s*:\s*\[([^\]]+)\]/);
                                    if (labelsMatch) {
                                        try {
                                            const labelsStr = labelsMatch[1];
                                            // Парсим labels вручную
                                            const labels = labelsStr.split(',').map(s => {
                                                s = s.trim().replace(/^["']|["']$/g, '');
                                                return s;
                                            });
                                            return { labels: labels, data: arr };
                                        } catch (e4) {
                                            // Если не получилось, создаем labels автоматически
                                            return { labels: arr.map((_, i) => `Элемент ${i + 1}`), data: arr };
                                        }
                                    }
                                    return { data: arr };
                                } catch (e3) {
                                    console.error('Не удалось распарсить массив:', cleaned);
                                }
                            }
                        }
                    }
                    
                    // Последняя попытка: извлекаем только массивы labels и data вручную
                    try {
                        // Ищем "labels":[...] и "data":[...]
                        const labelsPattern = /"labels"\s*:\s*\[([^\]]+)\]/;
                        const dataPattern = /"data"\s*:\s*\[([^\]]+)\]/;
                        
                        const labelsMatch = cleaned.match(labelsPattern) || jsonString.match(labelsPattern);
                        const dataMatch = cleaned.match(dataPattern) || jsonString.match(dataPattern);
                        
                        if (labelsMatch && dataMatch) {
                            // Парсим массивы вручную
                            const parseArray = (str) => {
                                return str.split(',').map(s => {
                                    s = s.trim();
                                    // Убираем кавычки
                                    s = s.replace(/^["']|["']$/g, '');
                                    // Пробуем распарсить как число
                                    const num = parseFloat(s);
                                    return isNaN(num) ? s : num;
                                });
                            };
                            
                            const labels = parseArray(labelsMatch[1]);
                            const data = parseArray(dataMatch[1]);
                            
                            if (labels.length > 0 && data.length > 0) {
                                return { labels: labels, data: data };
                            }
                        }
                    } catch (e5) {
                        console.error('Последняя попытка парсинга не удалась:', e5);
                    }
                    
                    console.error('Ошибка парсинга JSON:', e1, 'Строка:', cleaned.substring(0, 200));
                    return null;
                }
            }
            
            // Улучшенное регулярное выражение для захвата команд графиков
            // Используем более гибкий подход: сначала ищем точное совпадение, потом более общее
            const chartRegex = /\[CHART:(\w+):([^\]]+)\]/g;
            html = html.replace(chartRegex, (match, chartType, chartDataJson) => {
                const id = `CHART_${chartBlocks.length}_${Date.now()}`;
                
                // Очищаем и парсим JSON
                const chartData = cleanAndParseJSON(chartDataJson);
                
                if (!chartData) {
                    console.error('Не удалось распарсить данные графика:', chartDataJson);
                    return `<div class="chart-container error">Ошибка загрузки графика: неверный формат данных<br><small>${chartDataJson.substring(0, 100)}</small></div>`;
                }
                
                // Валидация данных
                if (!chartData.labels && !chartData.data) {
                    console.error('Отсутствуют обязательные поля labels или data:', chartData);
                    return `<div class="chart-container error">Ошибка: отсутствуют данные для графика (labels или data)</div>`;
                }
                
                // Если есть data но нет labels, создаем labels
                if (chartData.data && !chartData.labels) {
                    chartData.labels = chartData.data.map((_, i) => `Элемент ${i + 1}`);
                }
                
                // Если есть labels но нет data, создаем data из labels
                if (chartData.labels && !chartData.data) {
                    chartData.data = chartData.labels.map(() => 0);
                }
                
                // Убеждаемся, что data - это массив
                if (!Array.isArray(chartData.data)) {
                    chartData.data = [chartData.data];
                }
                
                // Убеждаемся, что labels - это массив
                if (!Array.isArray(chartData.labels)) {
                    chartData.labels = [chartData.labels];
                }
                
                // Проверяем соответствие длин
                if (chartData.labels.length !== chartData.data.length) {
                    const minLength = Math.min(chartData.labels.length, chartData.data.length);
                    chartData.labels = chartData.labels.slice(0, minLength);
                    chartData.data = chartData.data.slice(0, minLength);
                }
                
                chartBlocks.push({ id, type: chartType, data: chartData });
                html = html.replace(full, `<div id="chart_container_${id}" class="chart-container loading"></div>`);
            });
            
            // Таблицы: обработка Markdown таблиц (обрабатываем до замены переносов строк)
            const tableBlocks = [];
            // Ищем таблицы: строка с заголовками, строка с разделителем, строки данных
            const tableRegex = /(\|[^\n]+\|\n\|[-\s|:]+\|\n(?:\|[^\n]+\|\n?)+)/g;
            html = html.replace(tableRegex, (match) => {
                const id = `TABLE_${tableBlocks.length}`;
                
                // Разбиваем таблицу на строки
                const lines = match.trim().split('\n');
                if (lines.length < 2) {
                    return match; // Не таблица, возвращаем как есть
                }
                
                // Первая строка - заголовок
                const headerCells = lines[0].split('|').map(cell => cell.trim()).filter(cell => cell);
                
                // Вторая строка - разделитель с информацией о выравнивании
                const separatorLine = lines[1];
                const separatorCells = separatorLine.split('|').map(cell => cell.trim()).filter(cell => cell);
                
                // Функция для определения выравнивания из разделителя
                const getAlignment = (separator) => {
                    if (!separator) return 'left';
                    separator = separator.trim();
                    if (separator.startsWith(':') && separator.endsWith(':')) {
                        return 'center';
                    } else if (separator.endsWith(':')) {
                        return 'right';
                    } else {
                        return 'left';
                    }
                };
                
                // Определяем выравнивание для каждой колонки
                const alignments = separatorCells.map(sep => getAlignment(sep));
                
                let headerHTML = '<thead><tr>';
                headerCells.forEach((cell, index) => {
                    const align = alignments[index] || 'left';
                    const style = align === 'right' ? 'text-align: right;' : align === 'center' ? 'text-align: center;' : 'text-align: left;';
                    headerHTML += `<th class="markdown-table-th" style="${style}">${cell}</th>`;
                });
                headerHTML += '</tr></thead>';
                
                // Остальные строки (начиная с 3-й, так как 2-я - разделитель)
                let bodyHTML = '<tbody>';
                for (let i = 2; i < lines.length; i++) {
                    const cells = lines[i].split('|').map(cell => cell.trim()).filter(cell => cell);
                    if (cells.length > 0) {
                        bodyHTML += '<tr>';
                        cells.forEach((cell, index) => {
                            const align = alignments[index] || 'left';
                            const style = align === 'right' ? 'text-align: right;' : align === 'center' ? 'text-align: center;' : 'text-align: left;';
                            bodyHTML += `<td class="markdown-table-td" style="${style}">${cell}</td>`;
                        });
                        bodyHTML += '</tr>';
                    }
                }
                bodyHTML += '</tbody>';
                
                tableBlocks.push(`<table class="markdown-table">${headerHTML}${bodyHTML}</table>`);
                return id;
            });
            
            // Восстанавливаем таблицы
            tableBlocks.forEach((table, index) => {
                html = html.replace(`TABLE_${index}`, table);
            });
            
            // Рендерим графики после обработки HTML
            if (chartBlocks.length > 0) {
                setTimeout(() => {
                    chartBlocks.forEach((chartBlock) => {
                        const containerId = `chart_container_${chartBlock.id}`;
                        const container = document.getElementById(containerId);
                        if (container) {
                            container.classList.remove('loading');
                            
                            // Дополнительная валидация перед рендерингом
                            if (!chartBlock.data || !chartBlock.data.labels || !chartBlock.data.data) {
                                container.classList.add('error');
                                container.innerHTML = 'Ошибка: некорректные данные для графика';
                                return;
                            }
                            
                            if (chartBlock.data.labels.length === 0 || chartBlock.data.data.length === 0) {
                                container.classList.add('error');
                                container.innerHTML = 'Ошибка: нет данных для отображения';
                                return;
                            }
                            
                            renderChart(chartBlock.type, chartBlock.data, containerId).catch(error => {
                                console.error('Ошибка рендеринга графика:', error);
                                container.classList.add('error');
                                container.innerHTML = `Ошибка загрузки графика: ${error.message || 'неизвестная ошибка'}`;
                            });
                        }
                    });
                }, 100);
            }
            
            // Если есть таблицы, обрабатываем их отдельно
            const hasTable = html.includes('<table');
            
            if (hasTable) {
                // Разделяем контент на части: до таблицы, таблицы, после таблицы
                const parts = [];
                let currentText = '';
                let inTable = false;
                let tableContent = '';
                let tableDepth = 0;
                
                // Простой парсинг для разделения текста и таблиц
                const lines = html.split(/(<table[^>]*>[\s\S]*?<\/table>)/g);
                const result = [];
                
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i];
                    if (line.trim().startsWith('<table')) {
                        // Это таблица - добавляем как есть, без обертки
                        result.push(line);
                    } else if (line.trim()) {
                        // Это текст - обрабатываем переносы строк
                        const processedText = line.replace(/\n/g, '<br>');
                        // Оборачиваем только если это не пусто
                        if (processedText.trim()) {
                            result.push('<p class="markdown-paragraph">' + processedText + '</p>');
                        }
                    }
                }
                
                html = result.join('');
            } else {
                // Нет таблиц - обычная обработка
                html = html.replace(/\n/g, '<br>');
                if (!html.match(/^<(h[1-6]|ul|ol|pre|p|table)/)) {
                    html = '<p class="markdown-paragraph">' + html + '</p>';
                }
            }
            
            return html;
        }

        // Добавление сообщения в UI
        function addMessageToUI(text, isUser, files = null, filesData = null, autoScroll = true, messageIndex = -1) {
            const messagesArea = document.getElementById('chatMessages');
            const welcomeDiv = document.getElementById('chatWelcome');
            const capabilityMessages = document.getElementById('chatCapabilityMessages');
            
            if (welcomeDiv) {
                welcomeDiv.remove();
            }
            
            // Скрываем сообщения с возможностями при добавлении первого сообщения
            if (capabilityMessages) {
                capabilityMessages.remove();
            }

            const messageDiv = document.createElement('div');
            messageDiv.className = `chat-message ${isUser ? 'chat-message-user' : 'chat-message-ai'}`;
            if (messageIndex >= 0) {
                messageDiv.setAttribute('data-message-index', messageIndex);
            }
            
            let filesHTML = '';
            if (files && files.length > 0) {
                filesHTML = '<div class="chat-message-files">';
                files.forEach((file, index) => {
                    const fileData = filesData && filesData[index] ? filesData[index] : null;
                    if (fileData && fileData.data) {
                        // Если есть данные файла (только для текущей сессии)
                        if (file.type.startsWith('image/')) {
                            filesHTML += `<div class="chat-message-file"><img src="${fileData.data}" alt="${file.name}" class="chat-message-file-image"></div>`;
                        } else {
                            filesHTML += `<div class="chat-message-file"><a href="${fileData.data}" download="${file.name}" class="chat-message-file-link">📎 ${file.name} (${formatFileSize(file.size)})</a></div>`;
                        }
                    } else {
                        // Если данных нет (из истории чата) - показываем только метаданные
                        if (file.type.startsWith('image/')) {
                            filesHTML += `<div class="chat-message-file"><div class="chat-message-file-placeholder">🖼️ ${file.name} (${formatFileSize(file.size)})</div></div>`;
                        } else {
                            filesHTML += `<div class="chat-message-file"><div class="chat-message-file-placeholder">📎 ${file.name} (${formatFileSize(file.size)})</div></div>`;
                        }
                    }
                });
                filesHTML += '</div>';
            }
            
            // Преобразуем markdown в HTML только для сообщений AI
            const formattedText = isUser ? text : markdownToHTML(text);
            
            // Проверяем наличие таблицы в сообщении
            // Проверяем исходный текст (Markdown) и отрендеренный HTML
            const hasTableInText = hasTable(text);
            const hasTableInHTML = formattedText && (formattedText.includes('<table') || formattedText.includes('markdown-table'));
            const messageHasTable = hasTableInText || hasTableInHTML;
            
            // Проверяем наличие графика в сообщении
            const hasChartInText = text && (text.includes('[CHART_') || text.includes('[CHART:'));
            const hasChartInHTML = formattedText && formattedText.includes('chart-container');
            const messageHasChart = hasChartInText || hasChartInHTML;
            
            // Кнопка CSV должна показываться если есть таблица ИЛИ график
            const canExportCSV = messageHasTable || messageHasChart;
            
            // Отладочное логирование (можно убрать после проверки)
            if (messageHasTable || messageHasChart) {
                console.log('Найдены данные для CSV экспорта:', { 
                    messageIndex, 
                    hasTable: messageHasTable,
                    hasChart: messageHasChart,
                    hasTableInText, 
                    hasTableInHTML,
                    hasChartInText,
                    hasChartInHTML
                });
            }
            
            // Кнопки экспорта только для сообщений AI, не для пользователя
            let exportButtons = '';
            if (!isUser) {
                // Кнопка CSV если есть таблица или график
                const csvButton = canExportCSV ? 
                    `<button onclick="exportMessageCSV(${messageIndex})" title="Экспорт в CSV" style="padding: 4px 8px; background: #d3d3d3; color: #333; border: none; border-radius: 4px; cursor: pointer; font-size: 11px; display: flex; align-items: center; gap: 4px;"><img src="{% static 'images/csv.png' %}" alt="CSV" style="width: 16px; height: 16px;"> CSV</button>` : 
                    '';
                
                // Кнопки экспорта под каждым сообщением
                exportButtons = `
                    <div class="chat-message-actions" style="display: flex; gap: 5px; margin-top: 8px; flex-wrap: wrap; opacity: 0; transition: opacity 0.2s;">
                        <button onclick="exportMessageDOCX(${messageIndex})" title="Экспорт в DOCX" style="padding: 4px 8px; background: #d3d3d3; color: #333; border: none; border-radius: 4px; cursor: pointer; font-size: 11px; display: flex; align-items: center; gap: 4px;"><img src="{% static 'images/txt.png' %}" alt="DOCX" style="width: 16px; height: 16px;"> DOCX</button>
                        ${csvButton}
                        <button onclick="exportMessagePNG(${messageIndex})" title="Экспорт в PNG" style="padding: 4px 8px; background: #d3d3d3; color: #333; border: none; border-radius: 4px; cursor: pointer; font-size: 11px; display: flex; align-items: center; gap: 4px;"><img src="{% static 'images/png.png' %}" alt="PNG" style="width: 16px; height: 16px;"> PNG</button>
                    </div>
                `;
            }
            
            messageDiv.innerHTML = `
                <div class="chat-message-content" style="position: relative;">
                    ${formattedText ? `<div class="chat-message-text">${formattedText}</div>` : ''}
                    ${filesHTML}
                    ${exportButtons}
                </div>
            `;
            
            // Удаляем контейнеры вокруг таблиц после рендеринга
            setTimeout(() => {
                const messageTextDiv = messageDiv.querySelector('.chat-message-text');
                if (messageTextDiv) {
                    // Находим все таблицы
                    const tables = messageTextDiv.querySelectorAll('table.markdown-table, table');
                    tables.forEach(table => {
                        // Находим родительский контейнер (p, div и т.д.)
                        let parent = table.parentElement;
                        const originalParent = parent;
                        
                        // Если таблица обернута в параграф или div, поднимаем её на уровень выше
                        if (parent && (parent.tagName === 'P' || (parent.tagName === 'DIV' && parent.classList.contains('markdown-paragraph')))) {
                            const grandParent = parent.parentElement;
                            if (grandParent) {
                                // Вставляем таблицу перед родителем
                                grandParent.insertBefore(table, parent);
                                // Если родительский контейнер теперь пуст, удаляем его
                                if (originalParent && (!originalParent.textContent || originalParent.textContent.trim() === '')) {
                                    originalParent.remove();
                                }
                            }
                        }
                    });
                }
            }, 10);
            
            // Дополнительная проверка таблицы или графика после рендеринга (на случай, если проверка не сработала)
            if (!canExportCSV && messageIndex >= 0 && !isUser) {
                // Проверяем наличие таблицы или графика в отрендеренном HTML
                setTimeout(() => {
                    const messageTextDiv = messageDiv.querySelector('.chat-message-text');
                    let foundTable = false;
                    let foundChart = false;
                    
                    if (messageTextDiv) {
                        // Проверяем таблицы
                        const tables = messageTextDiv.querySelectorAll('table.markdown-table, table');
                        if (tables.length > 0) {
                            foundTable = true;
                        }
                    }
                    
                    // Проверяем графики
                    const chartContainers = messageDiv.querySelectorAll('.chart-container');
                    if (chartContainers.length > 0) {
                        foundChart = true;
                    }
                    
                    // Если нашли таблицу или график - добавляем кнопку CSV
                    if (foundTable || foundChart) {
                            const actionsDiv = messageDiv.querySelector('.chat-message-actions');
                            if (actionsDiv && !actionsDiv.querySelector('button[onclick*="exportMessageCSV"]')) {
                                const csvBtn = document.createElement('button');
                                csvBtn.onclick = () => exportMessageCSV(messageIndex);
                                csvBtn.title = 'Экспорт в CSV';
                                csvBtn.style.cssText = 'padding: 4px 8px; background: #d3d3d3; color: #333; border: none; border-radius: 4px; cursor: pointer; font-size: 11px; display: flex; align-items: center; gap: 4px;';
                                const csvImg = document.createElement('img');
                                csvImg.src = IMAGE_PATHS.csv;
                                csvImg.alt = 'CSV';
                                csvImg.style.cssText = 'width: 16px; height: 16px;';
                                csvBtn.appendChild(csvImg);
                                csvBtn.appendChild(document.createTextNode(' CSV'));
                                
                                // Вставляем перед кнопкой PNG
                                const pngBtn = actionsDiv.querySelector('button[onclick*="exportMessagePNG"]');
                                if (pngBtn) {
                                    actionsDiv.insertBefore(csvBtn, pngBtn);
                                } else {
                                    actionsDiv.appendChild(csvBtn);
                                }
                            }
                        }
                }, 500);
            }
            messagesArea.appendChild(messageDiv);
            
            // Удаляем надпись "markdown" если она есть
            setTimeout(() => {
                const messageTextDiv = messageDiv.querySelector('.chat-message-text');
                if (messageTextDiv) {
                    // Ищем и удаляем любые элементы с текстом "markdown"
                    const allElements = messageTextDiv.querySelectorAll('*');
                    allElements.forEach(el => {
                        if (el.textContent && el.textContent.trim().toLowerCase() === 'markdown') {
                            el.remove();
                        }
                    });
                    // Также проверяем текстовые узлы
                    const walker = document.createTreeWalker(
                        messageTextDiv,
                        NodeFilter.SHOW_TEXT,
                        null,
                        false
                    );
                    let node;
                    while (node = walker.nextNode()) {
                        if (node.textContent && node.textContent.trim().toLowerCase() === 'markdown') {
                            node.parentNode.removeChild(node);
                        }
                    }
                }
            }, 50);
            
            // Добавляем обработчик для показа кнопок при наведении
            const actionsDiv = messageDiv.querySelector('.chat-message-actions');
            if (actionsDiv) {
                messageDiv.addEventListener('mouseenter', () => {
                    actionsDiv.style.opacity = '1';
                });
                messageDiv.addEventListener('mouseleave', () => {
                    actionsDiv.style.opacity = '0';
                });
            }
            
            // Скроллим вниз только если нужно
            if (autoScroll) {
                // Используем requestAnimationFrame для синхронизации с рендерингом DOM
                requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                        scrollToBottomMessages(true);
                    });
                });
                
                // Дополнительные попытки с задержками для надежности (50ms, 200ms)
                setTimeout(() => {
                    scrollToBottomMessages(true);
                }, 50);
                setTimeout(() => {
                    scrollToBottomMessages(true);
                }, 200);
            }
        }

        // Отображение истории чатов
        function renderChatHistory() {
            const historySection = document.getElementById('chatHistorySection');
            if (!historySection) return;
            
            // Очищаем все существующие секции
            historySection.innerHTML = '';

            let filteredChats = chats;

            // Фильтр по избранному
            if (showFavoritesOnly) {
                filteredChats = chats.filter(chat => favorites.includes(chat.id) || pinnedChats.includes(chat.id));
            }

            // Фильтр по поиску
            if (searchQuery.trim()) {
                filteredChats = filteredChats.filter(chat => 
                    chat.title.toLowerCase().includes(searchQuery.toLowerCase())
                );
            }

            // Если показываем избранное
            if (showFavoritesOnly) {
                if (filteredChats.length > 0) {
                    renderChatSection(historySection, 'Избранное', filteredChats);
                }
                return;
            }

            // Группировка чатов по датам (используем дату последнего сообщения)
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            
            const yesterday = new Date(today);
            yesterday.setDate(yesterday.getDate() - 1);
            
            const todayChats = [];
            const yesterdayChats = [];
            const weekAgoChats = [];
            const monthAgoChats = [];

            // Получаем дату последнего сообщения или дату создания чата
            filteredChats.forEach(chat => {
                let chatDate;
                if (chat.messages && chat.messages.length > 0) {
                    // Используем дату последнего сообщения
                    const lastMessage = chat.messages[chat.messages.length - 1];
                    chatDate = new Date(lastMessage.timestamp);
                } else {
                    // Если сообщений нет, используем дату создания
                    chatDate = new Date(chat.createdAt);
                }
                chatDate.setHours(0, 0, 0, 0);
                const diffDays = Math.floor((today - chatDate) / (1000 * 60 * 60 * 24));

                if (diffDays === 0) {
                    todayChats.push(chat);
                } else if (diffDays === 1) {
                    yesterdayChats.push(chat);
                } else if (diffDays <= 7) {
                    weekAgoChats.push(chat);
                } else if (diffDays <= 30) {
                    monthAgoChats.push(chat);
                }
            });

            // Сортировка чатов внутри каждой категории по дате последнего сообщения (новые сверху)
            const sortChatsByLastMessage = (chatsArray) => {
                return chatsArray.sort((a, b) => {
                    // Сначала закрепленные
                    const aPinned = pinnedChats.includes(a.id);
                    const bPinned = pinnedChats.includes(b.id);
                    if (aPinned && !bPinned) return -1;
                    if (!aPinned && bPinned) return 1;
                    
                    // Затем по дате последнего сообщения
                    let aDate, bDate;
                    if (a.messages && a.messages.length > 0) {
                        aDate = new Date(a.messages[a.messages.length - 1].timestamp);
                    } else {
                        aDate = new Date(a.createdAt);
                    }
                    if (b.messages && b.messages.length > 0) {
                        bDate = new Date(b.messages[b.messages.length - 1].timestamp);
                    } else {
                        bDate = new Date(b.createdAt);
                    }
                    return bDate - aDate; // Новые сверху
                });
            };

            // Рендеринг секций в правильном порядке
            if (todayChats.length > 0) {
                renderChatSection(historySection, 'сегодня', sortChatsByLastMessage(todayChats));
            }
            if (yesterdayChats.length > 0) {
                renderChatSection(historySection, 'вчера', sortChatsByLastMessage(yesterdayChats));
            }
            if (weekAgoChats.length > 0) {
                renderChatSection(historySection, '7 дней назад', sortChatsByLastMessage(weekAgoChats));
            }
            if (monthAgoChats.length > 0) {
                renderChatSection(historySection, '30 дней назад', sortChatsByLastMessage(monthAgoChats));
            }
        }

        // Рендеринг секции чатов
        function renderChatSection(container, title, chats) {
            const section = document.createElement('div');
            section.className = 'chat-history-section';
            section.innerHTML = `
                <div class="chat-history-title">${title}</div>
                <div class="chat-history-items"></div>
            `;
            const itemsContainer = section.querySelector('.chat-history-items');
            
            // Чаты уже отсортированы в renderChatHistory, просто используем их
            const sortedChats = chats;
            
            sortedChats.forEach(chat => {
                const item = document.createElement('div');
                item.className = 'chat-history-item';
                item.dataset.chatId = chat.id;
                if (chat.id === currentChatId) {
                    item.classList.add('active');
                }
                // Убрали класс pinned, так как красная линия только для активного чата
                
                const isPinned = pinnedChats.includes(chat.id);
                const isFavorite = favorites.includes(chat.id);
                
                item.innerHTML = `
                    <div class="chat-history-item-content">
                        <span class="chat-history-item-title">${chat.title}</span>
                        <div class="chat-history-item-actions">
                            <button class="chat-pin-btn" data-chat-id="${chat.id}" title="${isPinned ? 'Открепить' : 'Закрепить'}">
                                <img src="${IMAGE_PATHS.zakrep2}" alt="${isPinned ? 'Открепить' : 'Закрепить'}" class="chat-action-icon">
                            </button>
                            <button class="chat-edit-btn" data-chat-id="${chat.id}" title="Редактировать">
                                <img src="${IMAGE_PATHS.red}" alt="Редактировать" class="chat-action-icon">
                            </button>
                            <button class="chat-delete-btn" data-chat-id="${chat.id}" title="Удалить">
                                <img src="${IMAGE_PATHS.udalit}" alt="Удалить" class="chat-action-icon">
                            </button>
                        </div>
                    </div>
                `;
                
                item.addEventListener('click', (e) => {
                    if (!e.target.closest('.chat-pin-btn') && 
                        !e.target.closest('.chat-edit-btn') && 
                        !e.target.closest('.chat-delete-btn')) {
                        loadChat(chat.id);
                    }
                });
                
                const pinBtn = item.querySelector('.chat-pin-btn');
                pinBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    togglePin(chat.id);
                });
                
                const editBtn = item.querySelector('.chat-edit-btn');
                editBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    editChatTitle(chat.id);
                });
                
                const deleteBtn = item.querySelector('.chat-delete-btn');
                deleteBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    deleteChat(chat.id);
                });
                
                itemsContainer.appendChild(item);
            });
            
            container.appendChild(section);
        }

        // Переключение закрепления
        function togglePin(chatId) {
            const index = pinnedChats.indexOf(chatId);
            if (index > -1) {
                pinnedChats.splice(index, 1);
                // Убираем из избранного при откреплении
                const favIndex = favorites.indexOf(chatId);
                if (favIndex > -1) {
                    favorites.splice(favIndex, 1);
                    saveUserFavorites(favorites);
                }
            } else {
                pinnedChats.push(chatId);
                // Добавляем в избранное при закреплении
                if (!favorites.includes(chatId)) {
                    favorites.push(chatId);
                    saveUserFavorites(favorites);
                }
            }
            saveUserPinnedChats(pinnedChats);
            renderChatHistory();
        }

        // Редактирование названия чата
        let editingChatId = null;

        function editChatTitle(chatId) {
            const chat = chats.find(c => c.id === chatId);
            if (!chat) return;

            editingChatId = chatId;
            document.getElementById('editChatTitleInput').value = chat.title;
            document.getElementById('editChatModal').style.display = 'flex';
        }

        function closeEditChatModal() {
            document.getElementById('editChatModal').style.display = 'none';
            editingChatId = null;
            document.getElementById('editChatTitleInput').value = '';
        }

        document.getElementById('saveEditChatBtn').addEventListener('click', () => {
            if (editingChatId) {
                const newTitle = document.getElementById('editChatTitleInput').value.trim();
                const chat = chats.find(c => c.id === editingChatId);
                if (chat && newTitle && newTitle !== chat.title) {
                    chat.title = newTitle;
                    saveChats();
                    renderChatHistory();
                    if (currentChatId === editingChatId) {
                        loadChat(editingChatId);
                    }
                }
                closeEditChatModal();
            }
        });

        // Закрытие модального окна редактирования при клике вне его
        document.getElementById('editChatModal').addEventListener('click', (e) => {
            if (e.target.id === 'editChatModal') {
                closeEditChatModal();
            }
        });

        // Сохранение по Enter в поле редактирования
        document.getElementById('editChatTitleInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                document.getElementById('saveEditChatBtn').click();
            }
        });

        // Модальное окно подтверждения
        let confirmCallback = null;

        function showConfirmModal(message, callback) {
            document.getElementById('confirmMessage').textContent = message;
            document.getElementById('confirmModal').style.display = 'flex';
            confirmCallback = callback;
        }

        function closeConfirmModal() {
            document.getElementById('confirmModal').style.display = 'none';
            confirmCallback = null;
        }

        document.getElementById('confirmBtn').addEventListener('click', () => {
            if (confirmCallback) {
                confirmCallback();
                closeConfirmModal();
            }
        });

        // Закрытие модального окна при клике вне его
        document.getElementById('confirmModal').addEventListener('click', (e) => {
            if (e.target.id === 'confirmModal') {
                closeConfirmModal();
            }
        });

        // Удаление чата
        function deleteChat(chatId) {
            showConfirmModal('Вы уверены, что хотите удалить этот чат?', () => {
                const chatIndex = chats.findIndex(c => c.id === chatId);
                if (chatIndex > -1) {
                    chats.splice(chatIndex, 1);
                    saveChats();

                    // Удаляем из избранного и закрепленных
                    const favIndex = favorites.indexOf(chatId);
                    if (favIndex > -1) {
                        favorites.splice(favIndex, 1);
                        saveUserFavorites(favorites);
                    }
                    const pinIndex = pinnedChats.indexOf(chatId);
                    if (pinIndex > -1) {
                        pinnedChats.splice(pinIndex, 1);
                        saveUserPinnedChats(pinnedChats);
                    }

                    // Если удалили текущий чат, загружаем другой или создаем новый
                    if (currentChatId === chatId) {
                        if (chats.length > 0) {
                            loadChat(chats[0].id);
                        } else {
                            currentChatId = null;
                            renderCapabilityMessages();
                        }
                    }

                    renderChatHistory();
                }
            });
        }

        // Переключение избранного
        function toggleFavorite(chatId) {
            const index = favorites.indexOf(chatId);
            if (index > -1) {
                favorites.splice(index, 1);
            } else {
                favorites.push(chatId);
            }
            saveUserFavorites(favorites);
            renderChatHistory();
        }

        // Обновление активного чата
        function updateActiveChat() {
            document.querySelectorAll('.chat-history-item').forEach(item => {
                item.classList.remove('active');
            });
            if (currentChatId) {
                const activeItem = document.querySelector(`[data-chat-id="${currentChatId}"]`)?.closest('.chat-history-item');
                if (activeItem) {
                    activeItem.classList.add('active');
                }
            }
        }

        // Обработка прикрепления файлов
        function handleFileAttach() {
            const fileInput = document.getElementById('fileInput');
            fileInput.click();
        }

        // Обработка выбранных файлов
        document.getElementById('fileInput').addEventListener('change', function(e) {
            const files = Array.from(e.target.files);
            if (files.length > 0) {
                const MAX_FILE_SIZE = 20 * 1024 * 1024; // 20 MB на файл
                const MAX_TOTAL_SIZE = 40 * 1024 * 1024; // 40 MB общий размер
                
                let totalSize = attachedFiles.reduce((sum, f) => sum + f.size, 0);
                const rejectedFiles = [];
                
                files.forEach(file => {
                    if (file.size > MAX_FILE_SIZE) {
                        rejectedFiles.push(`${file.name} (${formatFileSize(file.size)})`);
                    } else if (totalSize + file.size > MAX_TOTAL_SIZE) {
                        rejectedFiles.push(`${file.name} (превышен общий лимит)`);
                    } else {
                        attachedFiles.push({
                            name: file.name,
                            size: file.size,
                            type: file.type,
                            file: file
                        });
                        totalSize += file.size;
                    }
                });
                
                if (rejectedFiles.length > 0) {
                    showWarning(`Некоторые файлы не были добавлены:\n\n${rejectedFiles.join('\n')}\n\nМаксимальный размер файла: ${formatFileSize(MAX_FILE_SIZE)}\nМаксимальный общий размер: ${formatFileSize(MAX_TOTAL_SIZE)}`);
                }
                
                renderAttachedFiles();
                // Сброс input для возможности повторного выбора того же файла
                e.target.value = '';
            }
        });

        // Отображение прикрепленных файлов
        function renderAttachedFiles() {
            const attachedFilesDiv = document.getElementById('attachedFiles');
            if (attachedFiles.length === 0) {
                attachedFilesDiv.style.display = 'none';
                return;
            }

            attachedFilesDiv.style.display = 'block';
            attachedFilesDiv.innerHTML = attachedFiles.map((file, index) => `
                <div class="attached-file-item">
                    <span class="attached-file-name">${file.name}</span>
                    <span class="attached-file-size">${formatFileSize(file.size)}</span>
                    <button type="button" class="attached-file-remove" onclick="removeAttachedFile(${index})">×</button>
                </div>
            `).join('');
        }

        // Удаление прикрепленного файла (глобальная функция для onclick)
        window.removeAttachedFile = function(index) {
            if (attachedFiles && attachedFiles.length > index) {
                attachedFiles.splice(index, 1);
                renderAttachedFiles();
                // Сброс input для возможности повторного выбора того же файла
                document.getElementById('fileInput').value = '';
            }
        };

        // Форматирование размера файла
        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
        }

        // Переключение режима избранного
        function toggleFavoritesMode() {
            showFavoritesOnly = !showFavoritesOnly;
            const favoritesBtn = document.getElementById('favoritesBtn');
            if (showFavoritesOnly) {
                favoritesBtn.classList.add('active');
            } else {
                favoritesBtn.classList.remove('active');
            }
            renderChatHistory();
        }

        // Обработка поиска
        function handleSearch() {
            searchQuery = document.getElementById('chatSearchInput').value;
            renderChatHistory();
        }

        // Обработчики событий
        document.getElementById('attachBtn').addEventListener('click', handleFileAttach);
        document.getElementById('chatSendBtn').addEventListener('click', sendMessage);
        document.getElementById('chatInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                sendMessage();
            }
        });
        document.querySelector('.chat-new-chat-btn').addEventListener('click', createNewChat);
        document.getElementById('favoritesBtn').addEventListener('click', toggleFavoritesMode);
        document.getElementById('chatSearchInput').addEventListener('input', handleSearch);

        // Переключение темы в чате
        function toggleChatTheme() {
            const currentTheme = localStorage.getItem('theme') || 'light';
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            localStorage.setItem('theme', newTheme);
            applyTheme(newTheme);
            updateThemeButtonText();
        }

        // Обновление текста кнопки темы
        function updateThemeButtonText() {
            const theme = localStorage.getItem('theme') || 'light';
            const themeBtnText = document.getElementById('chatThemeBtnText');
            
            if (themeBtnText) {
                themeBtnText.textContent = theme === 'dark' ? 'Темная' : 'Светлая';
            }
        }

        // Применение темы
        function applyTheme(theme) {
            if (theme === 'dark') {
                document.body.classList.add('dark-theme');
            } else {
                document.body.classList.remove('dark-theme');
            }
        }



        // Автоматическое обновление истории каждую минуту для корректной сортировки
        setInterval(() => {
            renderChatHistory();
        }, 60000); // Обновляем каждую минуту

        // Инициализация при загрузке
        // Очищаем старые данные файлов один раз при загрузке
        cleanupOldFileData();
        initChat();
        
        // Применение сохраненной темы при загрузке
        const savedTheme = localStorage.getItem('theme') || 'light';
        applyTheme(savedTheme);
        updateThemeButtonText();
        
        // Функция для открытия/закрытия сайдбара на мобильных
        function toggleChatSidebar() {
            const sidebar = document.getElementById('chatSidebar');
            const overlay = document.getElementById('chatSidebarOverlay');
            const burgerBtn = document.getElementById('chatBurgerBtn');
            
            if (sidebar && overlay && burgerBtn) {
                const isOpen = sidebar.classList.contains('chat-sidebar-open');
                if (isOpen) {
                    sidebar.classList.remove('chat-sidebar-open');
                    overlay.classList.remove('chat-sidebar-overlay-active');
                    burgerBtn.classList.remove('chat-burger-active');
                } else {
                    sidebar.classList.add('chat-sidebar-open');
                    overlay.classList.add('chat-sidebar-overlay-active');
                    burgerBtn.classList.add('chat-burger-active');
                }
            }
        }
        
        // Функция для сворачивания/разворачивания боковой панели (только для десктопа)
        function toggleSidebarCollapse() {
            // Не работает на мобильных устройствах
            if (window.innerWidth <= 768) {
                return;
            }
            
            const sidebar = document.getElementById('chatSidebar');
            if (!sidebar) return;
            
            const isCollapsed = sidebar.classList.contains('chat-sidebar-collapsed');
            
            if (isCollapsed) {
                // Разворачиваем панель
                sidebar.classList.remove('chat-sidebar-collapsed');
                localStorage.setItem('chatSidebarCollapsed', 'false');
            } else {
                // Сворачиваем панель
                sidebar.classList.add('chat-sidebar-collapsed');
                localStorage.setItem('chatSidebarCollapsed', 'true');
            }
        }
        
        // Функция для обновления отступа области сообщений в зависимости от высоты поля ввода
        function updateMessagesAreaPadding() {
            const inputWrapper = document.querySelector('.chat-input-wrapper');
            const messagesArea = document.getElementById('chatMessages');
            
            if (!inputWrapper || !messagesArea) return;
            
            // Получаем высоту поля ввода
            const inputHeight = inputWrapper.offsetHeight;
            
            // Устанавливаем отступ снизу для области сообщений
            // Добавляем дополнительный отступ (20px) для визуального разделения
            const paddingBottom = inputHeight + 20;
            
            messagesArea.style.paddingBottom = `${paddingBottom}px`;
        }
        
        // Закрытие сайдбара при клике на ссылку в сайдбаре (на мобильных и планшетах)
        document.addEventListener('DOMContentLoaded', function() {
            // Обновление отступа области сообщений при загрузке страницы
            updateMessagesAreaPadding();
            
            // Восстановление состояния боковой панели при загрузке страницы
            // Только для десктопа
            if (window.innerWidth > 768) {
                const sidebar = document.getElementById('chatSidebar');
                const savedState = localStorage.getItem('chatSidebarCollapsed');
                
                if (sidebar && savedState === 'true') {
                    sidebar.classList.add('chat-sidebar-collapsed');
                }
            }
            
            const sidebarLinks = document.querySelectorAll('.chat-sidebar a, .chat-sidebar button');
            sidebarLinks.forEach(link => {
                link.addEventListener('click', function() {
                    // Небольшая задержка для плавного закрытия
                    setTimeout(() => {
                        if (window.innerWidth <= 768) {
                            toggleChatSidebar();
                        }
                    }, 100);
                });
            });
            
            // Обработка изменения размера окна
            let resizeTimeout;
            window.addEventListener('resize', function() {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(function() {
                    // Обновляем отступ при изменении размера окна
                    updateMessagesAreaPadding();
                    
                    const sidebar = document.getElementById('chatSidebar');
                    const overlay = document.getElementById('chatSidebarOverlay');
                    const burgerBtn = document.getElementById('chatBurgerBtn');
                    
                    if (window.innerWidth > 768) {
                        // На десктопе - убираем мобильные классы и восстанавливаем сохраненное состояние
                    if (sidebar && overlay && burgerBtn) {
                        sidebar.classList.remove('chat-sidebar-open');
                        overlay.classList.remove('chat-sidebar-overlay-active');
                        burgerBtn.classList.remove('chat-burger-active');
                    }
                        
                        // Восстанавливаем сохраненное состояние collapsed
                        const savedState = localStorage.getItem('chatSidebarCollapsed');
                        if (sidebar && savedState === 'true') {
                            sidebar.classList.add('chat-sidebar-collapsed');
                        } else if (sidebar) {
                            sidebar.classList.remove('chat-sidebar-collapsed');
                        }
                    } else {
                        // На мобильных - убираем класс collapsed
                        if (sidebar) {
                            sidebar.classList.remove('chat-sidebar-collapsed');
                        }
                    }
                }, 250);
            });
            
            // Обновление отступа при изменении содержимого поля ввода (например, при прикреплении файлов)
            const inputWrapper = document.querySelector('.chat-input-wrapper');
            if (inputWrapper) {
                // Используем MutationObserver для отслеживания изменений в поле ввода
                const observer = new MutationObserver(function(mutations) {
                    updateMessagesAreaPadding();
                });
                
                observer.observe(inputWrapper, {
                    childList: true,
                    subtree: true,
                    attributes: true,
                    attributeFilter: ['style', 'class']
                });
                
                // Также отслеживаем изменения размера через ResizeObserver
                if (window.ResizeObserver) {
                    const resizeObserver = new ResizeObserver(function(entries) {
                        updateMessagesAreaPadding();
                    });
                    
                    resizeObserver.observe(inputWrapper);
                }
            }
        });
    </script>
</body>
</html>

